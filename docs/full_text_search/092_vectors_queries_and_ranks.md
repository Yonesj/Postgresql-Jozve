پس از یک بررسی کوتاه در مورد `LIKE`، اکنون به سراغ ابزارهای اصلی و تخصصی PostgreSQL برای جستجوی تمام‌متن، یعنی `tsvector`، `tsquery` و `ts_rank` می‌رویم.

---

### **۱. مروری بر `tsvector`: تبدیل متن به فرمت قابل جستجو**

همانطور که جلسه مربوط به دیتا تایپ های full-text search دیدیم، تابع `to_tsvector` یک متن (مانند عنوان فیلم) را دریافت کرده و آن را به یک `tsvector` تبدیل می‌کند. این وکتور، لیستی مرتب‌شده از واژگان (lexemes) منحصر به فرد است.

```postgresql
SELECT title, to_tsvector(title)
FROM movies
LIMIT 50;
```

??? note "خروجی کوئری بالا"
    <div class='centered-div'>
      <img src="../../assets/images/full_text_search/92_1.png">
    </div>

*   **فرآیند تبدیل:** این تابع کلمات را به ریشه زبانی آن‌ها تبدیل می‌کند (مثلاً `Smashers` به `smasher` تبدیل می‌شود).
*   **حذف کلمات توقف (Stop Words):** کلمات رایج و بی‌اهمیت در جستجو (مانند `the`, `a`, `an`) به صورت خودکار از وکتور حذف می‌شوند تا جستجوها دقیق‌تر و کارآمدتر شوند.

---

### **۲. `tsquery`: زبان تخصصی برای ساخت کوئری جستجو**

`tsquery` یک دیتا تایپ و یک زبان تخصصی کوچک (`Domain Specific Language` یا `DSL`) برای تعریف کوئری‌های جستجو است. شما باید کوئری خود را با یک سینتکس خاص بنویسید تا PostgreSQL بتواند آن را در مقابل یک `tsvector` مقایسه کند. برای مقایسه یک `tsvector` و یک `tsquery`، از اپراتور `@@` استفاده می‌کنیم.

```postgresql
SELECT title
FROM movies
WHERE to_tsvector(title) @@ to_tsquery('star')
LIMIT 50;
```

??? note "خروجی کوئری بالا"
    <div class='centered-div'>
      <img src="../../assets/images/full_text_search/92_2.png">
    </div>

**اپراتورهای اصلی `tsquery`:**

  *   **`&` (AND):** هر دو کلمه باید در متن وجود داشته باشند. (`'star' & 'wars'`)
  *   **`|` (OR):** حداقل یکی از کلمات باید در متن وجود داشته باشد. (`'star' | 'wars'`)
  *   **`!` (NOT):** کلمه مورد نظر نباید در متن وجود داشته باشد. (`'trek' & !'generations'`)
  *   **`<->` (Followed By):** کلمه اول باید بلافاصله قبل از کلمه دوم آمده باشد. (`'star' <-> 'wars'`)
  *   **`<N>`:** بین دو کلمه باید دقیقاً `N-1` کلمه دیگر فاصله باشد. (`'star' <2> 'generations'`)


!!! tip "گروه‌بندی منطقی"
    شما می‌توانید با استفاده از پرانتز، اپراتورها را با هم گروه‌بندی کنید تا کوئری‌های پیچیده‌تری بسازید.
    ```    
    'star' <-> ('wars' | 'trek')
    ```

اگرچه این سینتکس بسیار قدرتمند است، اما ساختن آن به صورت دستی می‌تواند دشوار باشد. در جلسات آینده با توابع کمکی برای ساده‌سازی این فرآیند آشنا خواهیم شد.

---

### **۳. رتبه‌بندی نتایج با `ts_rank`**

برای اینکه نتایج جستجو را بر اساس **میزان ارتباط (relevance)** مرتب کنیم، از تابع `ts_rank` استفاده می‌کنیم. این تابع یک `tsvector` و یک `tsquery` را به عنوان ورودی دریافت کرده و یک امتیاز عددی (رتبه) را برمی‌گرداند. هرچه این امتیاز بالاتر باشد، نتیجه مرتبط‌تر در نظر گرفته می‌شود.

```postgresql
SELECT 
	title, 
	ts_rank(to_tsvector(title), to_tsquery('star & (wars | trek)')) AS rank
FROM 
	movies
WHERE 
	to_tsvector(title) @@ to_tsquery('star & (wars | trek)')
ORDER BY 
	rank DESC
LIMIT 50;
```

??? note "خروجی کوئری بالا"
    <div class='centered-div'>
      <img src="../../assets/images/full_text_search/92_3.png">
    </div>

`ts_rank` عواملی مانند تعداد تکرار کلمات کلیدی در متن را برای محاسبه امتیاز در نظر می‌گیرد.

---

### **۴. نگاهی به آینده: تنظیم دقیق جستجو**

تا به اینجا، پایه‌های اصلی جستجوی تمام‌متن را یاد گرفته‌ایم. در جلسات آینده، به سراغ تنظیمات دقیق‌تر خواهیم رفت. یاد می‌گیریم که چگونه:

*   جستجو را روی چند ستون (مانند `title` و `plot`) به صورت همزمان انجام دهیم.
*   به ستون‌های مختلف وزن‌های متفاوتی بدهیم (مثلاً تطابق در `title` امتیاز بیشتری از تطابق در `plot` داشته باشد).
*   تطابق‌های دقیق (exact matches) را با امتیاز بالاتری رتبه‌بندی کنیم.