تا به اینجا، موتور جستجوی ما نتایج خوبی را برمی‌گرداند، اما از نظر عملکردی بهینه نیست، زیرا در هر بار اجرای کوئری، مجبور به محاسبه `tsvector`ها در لحظه (`runtime`) هستیم. در این جلسه، این مشکل عملکردی را حل می‌کنیم.

---

### **۱. استراتژی اصلی: محاسبه و ذخیره‌سازی `tsvector`**

به جای محاسبه `tsvector` در هر کوئری، ما می‌خواهیم این مقدار را یک بار محاسبه کرده و در یک ستون **ذخیره کنیم**. سپس می‌توانیم کوئری‌های خود را روی این مقدار از پیش محاسبه شده اجرا کرده و روی آن ایندکس بسازیم تا سرعت جستجو به طرز چشمگیری افزایش یابد.

بهترین راه برای پیاده‌سازی این استراتژی، استفاده از یک **ستون تولیدی (generated column)** است.

---

### **۲. ایجاد یک ستون تولیدی برای `tsvector`**

ما یک ستون جدید (مثلاً به نام `search_vectors`) از نوع `tsvector` به جدول `movies` خود اضافه می‌کنیم و آن را به عنوان یک ستون تولیدی تعریف می‌کنیم.

```postgresql
ALTER TABLE movies ADD COLUMN search_vectors tsvector GENERATED ALWAYS AS (
    setweight(to_tsvector('english', coalesce(title, '')), 'A') ||
    ' ' ||
    setweight(to_tsvector('english', coalesce(plot, '')), 'B')
) STORED;
```

!!! note "نکات مهم در تعریف ستون"
    *   **مدیریت `NULL`:** برای جلوگیری از بروز خطا، بهتر است قبل از تبدیل ستون‌های `title` و `plot` به `tsvector`، با استفاده از `COALESCE` مقادیر `NULL` احتمالی آن‌ها را به یک رشته خالی تبدیل کنیم.

    *   **تابع قطعی (Deterministic):** همانطور که قبلاً دیدیم، برای استفاده از `to_tsvector` در یک ستون تولیدی، باید زبان را به صورت صریح مشخص کنیم تا تابع قطعی شود.

با این کار، PostgreSQL مسئولیت محاسبه و به‌روز نگه داشتن این ستون را بر عهده می‌گیرد. هر زمان که `title` یا `plot` یک فیلم تغییر کند، `search_vectors` نیز به صورت خودکار به‌روز خواهد شد.

---

### **۳. ساده‌سازی کوئری‌ها**

اکنون که ستون `search_vectors` را داریم، کوئری‌های ما بسیار ساده‌تر و خواناتر می‌شوند. دیگر نیازی به تکرار آن عبارت طولانی برای محاسبه `tsvector` در بخش‌های `WHERE` و `ORDER BY` نیست و می‌توانیم مستقیماً به نام این ستون جدید ارجاع دهیم.

```postgresql
SELECT 
	title, 
	ts_rank(search_vectors, to_tsquery('someQuery')) AS rank
FROM
	movies
WHERE
	search_vectors @@ to_tsquery('someQuery')
ORDER BY 
	rank DESC;
```

این کار نه تنها یک بهبود عملکردی است، بلکه یک بهبود در کیفیت زندگی (quality of life) برای توسعه‌دهنده نیز محسوب می‌شود.

---

### **۴. گام نهایی: افزودن ایندکس `GIN`**

آخرین و مهم‌ترین قدم برای افزایش سرعت جستجو، افزودن یک ایندکس روی ستون تولیدی `search_vectors` است. برای جستجوی تمام‌متن، بهترین نوع ایندکس، **ایندکس `GIN` (Generalized Inverted Index)** است.

```postgresql
CREATE INDEX movies_search_gin_idx ON movies USING GIN (search_vectors);
```

پس از ایجاد این ایندکس، `EXPLAIN` نشان می‌دهد که PostgreSQL به جای پیمایش کامل جدول، از یک `Index Scan` بسیار سریع روی ایندکس `GIN` استفاده می‌کند. این کار زمان اجرای کوئری را از چند صد میلی‌ثانیه به **کمتر از ده میلی‌ثانیه** کاهش می‌دهد.

```postgresql
EXPLAIN SELECT *
FROM 
	movies
WHERE 
	search_vectors @@ websearch_to_tsquery('"star wars"')
ORDER BY 
	ts_rank(search_vectors, websearch_to_tsquery('"star wars"'));
```

!!! note "خروجی کوئری بالا"
    <div class='centered-div'>
      <img src="../../assets/images/full_text_search/95.png">
    </div>

---

### **۵. جمع‌بندی**

با ترکیب سه قابلیت قدرتمند PostgreSQL، ما یک موتور جستجوی تمام‌متن بسیار کارآمد ساختیم:

1.  منطق جستجو و وزن‌دهی را با **`setweight`** و توابع `ts` تعریف کردیم.
2.  این منطق را در یک **ستون تولیدی** کپسوله کردیم تا به صورت خودکار به‌روز بماند و کوئری‌ها را ساده کند.
3.  روی آن ستون تولیدی یک **ایندکس `GIN`** ایجاد کردیم تا سرعت جستجو را به حداکثر برسانیم.

این راه‌حل یک موتور جستجوی بسیار قوی و قابل اعتماد را در اختیار شما قرار می‌دهد که می‌تواند برای مدت زمان بسیار طولانی، شما را از نیاز به ابزارهای جستجوی پیچیده‌تر و خارجی بی‌نیاز کند.