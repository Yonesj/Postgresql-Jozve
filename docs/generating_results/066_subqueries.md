### **جلسه ۶۶: زیرپرس‌وجوها (Subqueries)**

در این جلسه، به جای اتصال مستقیم دو جدول، یاد می‌گیریم چگونه یک جدول را با **نتیجه یک کوئری دیگر (زیرکوئری)** `JOIN` کنیم. این تکنیک بسیار قدرتمند است و به ما اجازه می‌دهد تا قبل از انجام اتصال نهایی، داده‌های غیرضروری را فیلتر کرده و عملکرد را بهینه کنیم.

---

#### **۱. ایده اصلی: اتصال به یک جدول مجازی**

به جای اتصال مستقیم جدول `users` به کل جدول `bookmarks`، می‌توانیم ابتدا یک زیرکوئری بنویسیم که فقط بوکمارک‌های مورد نظر ما (مثلاً URLهای امن با `https`) را انتخاب کند. سپس، نتیجه این زیرکوئری (که مانند یک جدول مجازی عمل می‌کند) را با جدول `users` اتصال دهیم. این کار از ایجاد یک اتصال بزرگ و پرهزینه روی داده‌هایی که به آن‌ها نیازی نداریم، جلوگیری می‌کند.

```postgresql
SELECT users.first_name, url
FROM users
LEFT JOIN (
  SELECT * FROM bookmarks WHERE starts_with(url, 'https')
) AS bookmarks_secure ON users.id = bookmarks_secure.user_id;
```

در مثال بالا، مجموعهٔ میانی `bookmarks_secure` تنها شامل بوکمارک‌های `https` است و سپس با `users` LEFT JOIN می‌شود تا همهٔ کاربران همراه با بوکمارک‌های امن‌شان (در صورت وجود) نمایش داده شوند.

---

#### **۲. نحوه تعریف و نام‌گذاری (aliasing) یک زیرکوئری**

نتیجهٔ یک زیرپرس‌وجو باید یک نام (alias) داشته باشد تا در عبارت JOIN قابل ارجاع باشد. نوشتن `AS` اختیاری است، اما استفاده از آن وضوح را افزایش می‌دهد.

```postgresql
-- با AS
LEFT JOIN (
  SELECT * FROM bookmarks WHERE starts_with(url, 'https')
) AS bookmarks_secure ON users.id = bookmarks_secure.user_id;

-- AS بدون
LEFT JOIN (
  SELECT * FROM bookmarks WHERE starts_with(url, 'https')
) bookmarks_secure ON users.id = bookmarks_secure.user_id;
```

---

#### **۳. فیلتر کردن قبل از `JOIN` در مقابل فیلتر کردن بعد از `JOIN`**

شما می‌توانید شرط فیلتر خود را هم قبل از `JOIN` (در داخل زیرکوئری) و هم بعد از `JOIN` (در `WHERE` اصلی) قرار دهید. هر دو روش ممکن است نتیجه یکسانی بدهند، اما فیلتر کردن **قبل از `JOIN`** معمولاً بسیار بهینه‌تر است، زیرا حجم داده‌هایی را که باید در عملیات اتصال شرکت کنند، به شدت کاهش می‌دهد.

---

#### **۴. بهینه‌سازی زیرکوئری با ایندکس‌های تابعی و ترکیبی**

برای تسریع تشخیص URLهای `https` می‌توان یک ایندکس تابعی ساخت که عبارت شرطی را ایندکس کند. مثالِ سادهٔ ایجاد ایندکس روی عبارت `starts_with(url, 'https')`:

```postgresql
CREATE INDEX bookmarks_secure_url ON bookmarks ((starts_with(url, 'https')));
```

این ایندکس یک ایندکس بر روی نتیجهٔ عبارت بولی `starts_with(url,'https')` می‌سازد که در بعضی الگوها می‌تواند برای جستجوهای پیش‌فرض مفید باشد.
برای اینکه ایندکس در سناریوی JOIN واقعی قابل‌استفاده باشد، معمولاً باید ستون های مورد استفاده در شرط JOIN در ابتدای تعریف ایندکس قرار گیرند. بنابراین یک ایندکس مرکب شامل `user_id` و عبارت تابعی ایجاد می کنیم:

```postgresql
DROP INDEX bookmarks_secure_url;

CREATE INDEX bookmarks_secure_user_secure
  ON bookmarks (user_id, (starts_with(url, 'https')));
```

ترتیب ستون‌ها مهم است: وقتی `user_id` به‌عنوان ستونِ پیشرو در ایندکس قرار می‌گیرد و شرط JOIN بر `user_id` نوشته می‌شود، موتور پایگاه‌داده می‌تواند از ایندکس برای دسترسی سریع استفاده کند.

---

#### **۵. تحلیل طرح اجرایی (`EXPLAIN`)**

اگر فقط روی عبارت تابعی فیلتر بزنید (مثلاً `WHERE starts_with(url,'https')`) و ایندکس مرکب با پیشرو `user_id` وجود داشته باشد، ممکن است planner از یک **sequential scan** استفاده کند زیرا قسمت تابعی ایندکس در جای دوم قرار دارد و بدون شرط مساوی روی `user_id` قابل‌استفاده نیست (index blocking).

<div class='centered-div'>
  <img src="../../assets/images/generating_results/66.png">
</div>

اما زمانی که همان عبارت در قالب زیرپرس‌وجو و سپس با یک JOIN روی `user_id` استفاده شود، ایندکس مرکب قابل استفاده می‌شود و EXPLAIN نشان‌دهندهٔ **Index Scan** روی ایندکس مرکب خواهد بود. به عبارت دیگر، شرایط دسترسی و ترتیب ایندکس تعیین‌کنندهٔ استفاده از ایندکس است.

```postgresql
EXPLAIN
SELECT users.first_name, bs.url
FROM users
LEFT JOIN (
  SELECT * FROM bookmarks WHERE starts_with(url, 'https')
) AS bs ON users.id = bs.user_id
LIMIT 100;
```

<div class='centered-div'>
  <img src="../../assets/images/generating_results/66_2.png">
</div>
---

#### **۶. جمع‌بندی**

1. استفاده از زیرپرس‌وجو برای فیلتر پیش از JOIN باعث کاهش حجم دادهٔ ترکیب‌شونده می‌شود.
2. نتیجهٔ یک زیرپرس‌وجو باید alias داشته باشد تا در عبارت JOIN قابل‌ارجاع باشد؛ `AS` اختیاری است.
3. ایندکس تابعی می‌تواند فیلترهای مبتنی بر عبارت را تسریع کند، ولی ترتیب ستون‌ها در ایندکس مرکب تعیین می‌کند آیا ایندکس در سناریوی JOIN قابل‌استفاده است یا خیر.
4. EXPLAIN را برای بررسی اینکه planner از Index Scan یا Sequential Scan استفاده می‌کند به‌کار ببرید؛ وقتی شرط‌های JOIN و ترتیب ایندکس هماهنگ باشند، ایندکس مرکب می‌تواند Index Scan تولید کند و کارایی را افزایش دهد.
