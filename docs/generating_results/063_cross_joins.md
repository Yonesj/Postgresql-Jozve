### **جلسه ۶۳: اتصال متقاطع (CROSS JOIN)**

تا به اینجا، تمام کوئری‌های ما روی یک جدول واحد اجرا می‌شدند. اکنون زمان آن رسیده که یاد بگیریم چگونه جداول مختلف را در کنار یکدیگر قرار داده و داده‌های آن‌ها را با استفاده از `JOIN`ها ترکیب کنیم. ما این سفر را با یکی از انواع خاص `JOIN` که شاید کمتر رایج باشد اما در موارد خاص بسیار قدرتمند است، یعنی `CROSS JOIN`، آغاز می‌کنیم.

---

#### **۱. تعریف پایه: حاصل‌ضرب دکارتی (Cartesian Product)**

یک `CROSS JOIN` هر ردیف از جدول اول را با هر ردیف از جدول دوم جفت می‌کند. نتیجه این عملیات، یک **حاصل‌ضرب دکارتی (Cartesian product)** است. به عبارت دیگر، اگر جدول اول `m` ردیف و جدول دوم `n` ردیف داشته باشد، نتیجه نهایی `m × n` ردیف خواهد بود. برای مثال، اگر جدولی با ۵ حرف و جدول دیگری با ۵ عدد داشته باشیم، `CROSS JOIN` آن‌ها ۲۵ ردیف (تمام ترکیبات ممکن) تولید خواهد کرد.

---

#### **۲. نوشتار ضمنی با کاما و نوشتار صریح با `CROSS JOIN`**

می‌توان دو جدول را با گذاشتن کاما بین آن‌ها در بخش `FROM` کنار هم قرار داد؛ این نگارش ضمنی همان `CROSS JOIN` است. نگارش صریح با `CROSS JOIN` دقیقاً نتیجهٔ یکسان می‌دهد.

```postgresql
-- نگارش ضمنی (معادل CROSS JOIN)
SELECT * FROM letters, numbers;

-- نگارش صریح
SELECT * FROM letters CROSS JOIN numbers;
```

---

#### **۳. مثال ساده: ترکیب حروف و اعداد و نمایش ترتیب‌ها**

فرض کنید دو جدول یا مجموعهٔ موقت داریم: یکی شامل حروف (A..E) و دیگری شامل اعداد (1..5). `CROSS JOIN` تمام ترکیب‌های ممکن را می‌سازد: A1, A2, …, E5.

```postgresql
SELECT UPPER(letter) || number
FROM letters, numbers
```

تعداد ردیف‌ها در این مثال `5 × 5 = 25` خواهد بود.

---

#### **۴. تولید مجموعه‌ها به‌صورت پویا با `generate_series`**

نقطه قوت واقعی `CROSS JOIN` زمانی آشکار می‌شود که آن را با توابع مجموعه‌ساز (set-generating functions) مانند `generate_series` ترکیب کنیم. به جای ایجاد جداول فیزیکی برای نگهداری حروف یا اعداد، می‌توانیم این سری‌ها را در لحظه تولید کنیم.

```postgresql
SELECT * FROM generate_series(65, 75); -- [65, 75]

SELECT *
FROM generate_series(65,74) AS letters(l)
CROSS JOIN generate_series(1,10) AS numbers(n);

-- l  |  n
----------
-- 65 |  1
-- 66 |  2
-- .  |  .
-- .  |  .
```

در این مثال ستون `l` شامل مقادیر عددی ASCII است که در مرحلهٔ بعد با `()CHR` به کاراکتر تبدیل می‌شوند.

---

#### **۵. تبدیل مقادیر ASCII به حروف با `()CHR` و ساخت کدها**

برای تبدیل کدهای ASCII به حروف می‌توان از `()CHR` استفاده کرد و سپس با عملگر `||` (concat) یا تابع `()CONCAT` ترکیب رشته و عدد را ساخت. با `()UPPER` می‌توان به‌صورت اختیاری حروف را به حروف بزرگ تبدیل کرد.

```postgresql
SELECT UPPER(CHR(l) || n)
FROM generate_series(65,90) AS letters(l)
CROSS JOIN generate_series(1,100) AS numbers(n);
```

خروجی این پرس‌وجو شامل ترکیب‌هایی مانند `A1` تا `Z100` خواهد بود (با توجه به بازهٔ `generate_series`).

---

#### **۶. نام‌گذاری (alias) و بسته‌بندی نتایج**

می‌توان مجموعهٔ تولیدشده را در پرانتز قرار داد و به‌صورت یک ستون یا یک مجموعهٔ با نام مشخص در خروجی برگرداند:

```postgresql
SELECT (UPPER(CHR(l) || n)) AS code
FROM generate_series(65,90) AS letters(l)
CROSS JOIN generate_series(1,100) AS numbers(n);
```

این نگارش یک ستون `code` تولید می‌کند که شامل تمام ترکیب‌های حروف و اعداد است.

---

#### **۷. اندازهٔ خروجی و پیامدهای اجرایی (ملاحظات عملکردی)**

نتیجهٔ یک `CROSS JOIN` به‌سرعت می‌تواند بسیار بزرگ شود زیرا تعداد ردیف‌ها ضرب می‌شود. هنگام ترکیب بازه‌های بزرگ با `generate_series` یا جدول‌های بزرگ، باید انتظار حجم خروجی بزرگ و بار پردازشی زیاد را داشته باشید.

---

#### **۸. جمع‌بندی فنی**

`CROSS JOIN` راهی مستقیم برای تولید تمام ترکیب‌های ممکن بین دو مجموعه است و با توابع تولیدکنندهٔ مجموعه مانند `generate_series` امکان تولید ترکیب‌های پویا (مثلاً کدها یا ماتریس‌های ترکیبی) را فراهم می‌کند. هنگام استفاده، به اندازهٔ حاصل‌ضرب و حدود بازه‌ها دقت کنید تا خروجی دقیقاً مطابق انتظار باشد.
