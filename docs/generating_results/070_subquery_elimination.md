### **جلسه ۷۰: حذف ردیف‌ها با زیرکوئری (Subquery Elimination)**

تا به اینجا، از زیرکوئری‌ها برای تولید یک مجموعه نتیجه و سپس `JOIN` کردن آن استفاده کرده‌ایم. در این جلسه، یاد می‌گیریم چگونه از یک زیرکوئری به عنوان یک **فیلتر** برای حذف یا انتخاب ردیف‌ها از یک جدول استفاده کنیم، **بدون اینکه نیاز به `JOIN` و آوردن داده‌های اضافی از جدول مرتبط داشته باشیم**.

---

#### **۱. سناریو: پیدا کردن کاربران بر اساس داده‌های مرتبط**

فرض کنید می‌خواهیم کاربرانی را پیدا کنیم که یک ویژگی خاص در داده‌های مرتبطشان دارند (مثلاً کاربرانی که بیش از ۱۶ بوکمارک دارند، یا تیم‌هایی با بیش از ۲۰ عضو). ما به خود داده‌های مرتبط (بوکمارک‌ها یا اعضا) نیازی نداریم، فقط خود کاربران را می‌خواهیم. استفاده از `JOIN` در اینجا داده‌های اضافی را به همراه می‌آورد. اینجاست که زیرکوئری به عنوان فیلتر به کار می‌آید.

---

#### **۲. روش اول: استفاده از `WHERE ... IN`**

در این روش، ابتدا یک زیرکوئری می‌نویسیم که لیست شناسه‌های مورد نظر را استخراج کند. برای مثال، برای پیدا کردن `user_id` کاربرانی که بیش از ۱۶ بوکمارک دارند، از `GROUP BY` و `HAVING` استفاده می‌کنیم. `HAVING` مانند `WHERE` عمل می‌کند، اما روی نتایج تجمیع شده پس از `GROUP BY` اعمال می‌شود.

سپس، از این لیست در شرط `WHERE IN` کوئری اصلی خود استفاده می‌کنیم تا فقط کاربرانی را که `id` آن‌ها در این لیست وجود دارد، انتخاب کنیم.

```postgresql
SELECT *
FROM users
WHERE id IN (
	SELECT user_id
	FROM bookmarks
	GROUP BY user_id
	HAVING count(*) > 16
);
```

**نکته مهم در مورد عملکرد (Semi-Join):**
PostgreSQL در اجرای این کوئری هوشمندانه عمل می‌کند و آن را به عنوان یک **semi-join** بهینه می‌کند. این به این معناست که پایگاه داده از روش `query decomposition` استفاده نمی کند. (روشی که ابتدا زیرکوئری اجرا شده و لیستی از IDها در کوئری اصلی جایگذاری می‌شوند). در عوض، کل عملیات را به عنوان یک کوئری واحد و بهینه شده در نظر می‌گیرد. برای فیلتر کردن ردیف‌هایی که در لیست **نیستند** نیز می‌توان از `WHERE ... NOT IN` استفاده کرد (که به آن **anti-join** می‌گویند).

---

#### **۳. روش دوم: استفاده از `WHERE EXISTS`**

یک روش دیگر برای فیلتر کردن با زیرکوئری، استفاده از `WHERE EXISTS` است.

```postgresql
SELECT *
FROM users
WHERE EXISTS (
	SELECT 1 FROM bookmarks
	WHERE bookmarks.user_id = users.id
	GROUP BY user_id
	HAVING count(*) > 16
);
```

تفاوت اصلی این روش با `IN` در دو چیز است:

1.  **ارجاع به جدول بیرونی:** در زیرکوئری `EXISTS`، شما می‌توانید به ستون‌های جدول بیرونی ارجاع دهید و یک **کوئری همبسته (correlated subquery)** بنویسید.
2.  **اجرا به ازای هر ردیف:** زیرکوئری `EXISTS` به ازای **هر ردیف** از جدول بیرونی یک بار اجرا می‌شود.

در `EXISTS`، مهم نیست که زیرکوئری چه چیزی را `SELECT` می‌کند (معمولاً از `SELECT 1` استفاده می‌شود)؛ تنها چیزی که اهمیت دارد، **وجود یا عدم وجود حداقل یک ردیف** در خروجی آن است.

---

#### **۴. مقایسه `IN` در مقابل `EXISTS`: کدام بهتر است؟**

هیچ پاسخ قطعی برای این سوال وجود ندارد و انتخاب بین این دو **کاملاً به سناریو بستگی دارد**.

- **`IN`** معمولاً زمانی بهتر عمل می‌کند که زیرکوئری شما مستقل است و نتیجه کوچکی را برمی‌گرداند. PostgreSQL زیرکوئری را **یک بار** اجرا کرده و از نتیجه آن برای فیلتر کردن استفاده می‌کند.

- **`EXISTS`** معمولاً زمانی بهتر عمل می‌کند که شما فقط به دنبال **وجود یا عدم وجود** یک ردیف مطابق با شرط هستید. `EXISTS` به محض پیدا کردن **اولین** ردیف منطبق، اجرای زیرکوئری را متوقف کرده (**short-circuit**) و نتیجه `true` را برمی‌گرداند. این ویژگی می‌تواند بسیار کارآمد باشد.

**تحلیل با `EXPLAIN ANALYZE`:**
در مثال "پیدا کردن کاربران با بیش از ۱۶ بوکمارک"، `EXPLAIN ANALYZE` نشان می‌دهد که `IN` بسیار سریع‌تر است، زیرا زیرکوئری آن فقط **یک بار** اجرا می‌شود. اما `EXISTS` به دلیل وجود `GROUP BY` و `COUNT`، قابلیت `short-circuit` خود را از دست داده و زیرکوئری را به ازای هر کاربر (نزدیک به یک میلیون بار) اجرا می‌کند که عملکرد فاجعه‌باری دارد.

اما در سناریوی "پیدا کردن کاربرانی که حداقل یک بوکمارک امن دارند"، `EXISTS` به دلیل قابلیت `short-circuit` خود، می‌تواند بسیار کارآمدتر باشد، زیرا به محض پیدا کردن اولین بوکمارک امن برای هر کاربر، جستجو را متوقف می‌کند.

---

#### **۵. تله مرگبار `NOT IN` با مقادیر `NULL`**

یک نکته بسیار حیاتی و خطرناک در مورد `NOT IN` وجود دارد:

اگر زیرکوئری یا لیستی که در `NOT IN` استفاده می‌کنید، **حتی یک مقدار `NULL`** را برگرداند، کل کوئری `NOT IN` **هیچ ردیفی را برنمی‌گرداند!**

```postgresql
SELECT * FROM users WHERE id NOT IN (
	VALUES (1), (2), (NULL)
); -- output nothing
```

این به دلیل رفتار مقایسه با `NULL` است. برای جلوگیری از این مشکل، باید همیشه مطمئن شوید که زیرکوئری شما هرگز `NULL` برنمی‌گرداند (مثلاً با افزودن `WHERE user_id IS NOT NULL`)، یا به جای آن از `NOT EXISTS` استفاده کنید که با وجود یا عدم وجود ردیف کار می‌کند و با مقادیر `NULL` به این شکل دچار مشکل نمی‌شود.

---

#### **۶. جمع‌بندی**

استفاده از زیرکوئری‌ها برای فیلتر کردن ردیف‌ها بدون نیاز به `JOIN`، یک تکنیک بسیار قدرتمند است. تفاوت‌های عملکردی بین `WHERE IN` و `WHERE EXISTS` را به خوبی درک کنید و همیشه با `EXPLAIN ANALYZE` و بر اساس داده‌ها و کوئری واقعی خود، بهترین گزینه را انتخاب کنید. همچنین، مراقب تله `NOT IN` با مقادیر `NULL` باشید.
