### **جلسه ۶۹: پر کردن شکاف‌ها در دنباله‌ها**

این یکی از جذاب‌ترین بخش‌های دوره است، زیرا قطعات کوچکی که تا به حال یاد گرفته‌ایم، در کنار هم قرار می‌گیرند تا یک راه‌حل قدرتمند برای یک مسئله واقعی ایجاد کنند. ما در این جلسه یاد می‌گیریم که چگونه با استفاده از `generate_series` و `LEFT JOIN`، شکاف‌ها یا داده‌های ناقص را در یک سری زمانی (مانند گزارش فروش) پر کنیم.

---

#### **۱. شناسایی مسئله: شکاف در داده‌های زمانی**

فرض کنید یک جدول فروش (`sales`) داریم و می‌خواهیم یک گزارش از مجموع فروش روزانه تهیه کنیم. وقتی داده‌ها را بر اساس تاریخ گروه‌بندی می‌کنیم، ممکن است متوجه شویم که برای برخی روزها (مثلاً چهارم ژانویه) هیچ داده‌ای وجود ندارد، زیرا در آن روز فروشی ثبت نشده است. در گزارش نهایی، این روزها به سادگی **حذف می‌شوند** و یک شکاف در دنباله زمانی ایجاد می‌کنند. این شکاف می‌تواند گزارش را گمراه‌کننده و تحلیل آن را دشوار کند.

```postgresql
-- sales(id, user_id, sale_date, amount)
SELECT sale_date, SUM(amount)
FROM sales
GROUP BY sale_date
ORDER BY sale_date;
```

هدف ما این است که گزارشی تولید کنیم که **تمام روزهای یک بازه زمانی مشخص** را شامل شود و برای روزهایی که فروشی وجود نداشته، مقدار صفر را نمایش دهد.

---

#### **۲. استراتژی حل: `generate_series` به عنوان پایه و `LEFT JOIN`**

راه‌حل این مسئله، ترکیب هوشمندانه دو ابزاری است که قبلاً با آن‌ها آشنا شده‌ایم:

1.  **ایجاد یک لیست کامل از تاریخ‌ها:** ابتدا با استفاده از `generate_series`، یک لیست کامل و بدون شکاف از تمام تاریخ‌های مورد نظر خود (مثلاً از اول تا سی و یکم ژانویه) ایجاد می‌کنیم. این لیست به عنوان جدول **چپ** و پایه اصلی `JOIN` ما عمل خواهد کرد.

2.  **آماده‌سازی داده‌های فروش:** در یک زیرکوئری (`subquery`)، داده‌های جدول `sales` را بر اساس تاریخ گروه‌بندی کرده و مجموع فروش هر روز را محاسبه می‌کنیم.

3.  **استفاده از `LEFT JOIN`:** سپس، لیست کامل تاریخ‌ها (جدول چپ) را به نتیجه زیرکوئری (جدول راست) `LEFT JOIN` می‌کنیم. از آنجایی که `LEFT JOIN` تمام ردیف‌های جدول چپ را حفظ می‌کند، ما تضمین می‌کنیم که تمام روزها در نتیجه نهایی حضور خواهند داشت. برای روزهایی که در جدول فروش مطابقی وجود ندارد، ستون‌های مربوط به فروش (مانند `total_amount`) با مقدار `NULL` پر خواهند شد.

---

#### **۳. تکمیل راه‌حل با تابع `COALESCE`**

در مرحله قبل، برای روزهای بدون فروش، مقدار `NULL` را در ستون مجموع فروش داریم. برای اینکه گزارش ما تمیزتر باشد و به جای `NULL`، عدد **صفر** را نمایش دهیم، از تابع `COALESCE` استفاده می‌کنیم.

```postgresql
COALESCE(total_amount, 0)
```

تابع `COALESCE` اولین آرگومان غیر `NULL` را از لیست آرگومان‌های خود برمی‌گرداند. در این حالت، اگر `total_amount` برابر `NULL` باشد، تابع از آن عبور کرده و مقدار `0` را انتخاب می‌کند. به یاد داشته باشید که `NULL` (نامشخص) با `0` (مقدار صفر) کاملاً متفاوت است.

---

#### **۴. کوئری نهایی**

کوئری نهایی که تمام این مراحل را با هم ترکیب می‌کند، به صورت زیر خواهد بود:

```postgresql
SELECT
	(all_dates.sale_date)::date,
	COALESCE(sales.total_amount, 0) AS total_sales
FROM
	generate_series('2024-01-01'::date, '2024-01-31'::date, '1 day') AS all_dates(sale_date)
	LEFT JOIN (
		SELECT sale_date, SUM(amount) AS total_amount
		FROM sales
		GROUP BY sale_date
	) AS sales ON all_dates.sale_date = sales.sale_date
ORDER BY all_dates.sale_date;
```

---

#### **۵. جمع‌بندی**

این تکنیک یک نمونه عالی از قدرت ترکیبی ابزارهای PostgreSQL است. در حالی که در بسیاری از پایگاه‌های داده دیگر برای حل این مسئله نیاز به استفاده از `Recursive CTE`های پیچیده دارید، در PostgreSQL می‌توان با ترکیب ساده `generate_series` و `LEFT JOIN` به یک راه‌حل بسیار خوانا و کارآمد دست یافت.
