### **جلسه ۷۳: ایندکس‌گذاری روی JOINها**

در این جلسه، به بررسی نحوه افزودن ایندکس برای افزایش سرعت عملیات `JOIN` می‌پردازیم و روی ستون‌های کلید خارجی (foreign keys) ایندکس ایجاد می‌کنیم.

---

#### **۱. یک تصور غلط رایج: کلید خارجی به صورت خودکار ایندکس می‌شود**

باید به یاد داشته باشیم که اگرچه ایجاد یک کلید اصلی (`PRIMARY KEY`) یا یک محدودیت `UNIQUE` در جدول والد، به صورت خودکار یک ایندکس در آن جدول ایجاد می‌کند، اما ایجاد یک **محدودیت کلید خارجی (foreign key constraint)** در جدول فرزند، به صورت خودکار هیچ ایندکسی در آن جدول ایجاد **نمی‌کند**.

این یک نکته بسیار مهم است. اگرچه شما یکپارچگی ارجاعی را تضمین کرده‌اید، اما اگر روی ستون کلید خارجی در جدول فرزند ایندکس نداشته باشید، عملیات `JOIN` شما ممکن است با مشکلات عملکردی جدی مواجه شود.

---

#### **۲. مشکل عملکردی `JOIN` بدون ایندکس**

برای درک مشکل، یک `JOIN` بین جداول `users` و `bookmarks` را با `EXPLAIN` بررسی می‌کنیم.

```postgresql
SELECT *
FROM users JOIN bookmarks ON users.id = bookmarks.user_id
WHERE users.id < 100;
```

در طرح اجرایی این کوئری، می‌بینیم که PostgreSQL برای پیدا کردن کاربران (`users.id < 100`) از ایندکس کلید اصلی جدول `users` استفاده می‌کند که بسیار کارآمد است. اما سپس، برای پیدا کردن بوکمارک‌های متناظر، مجبور است **کل جدول `bookmarks` را به صورت ترتیبی اسکن کند (Sequential Scan)**.

<div class='centered-div'>
  <img src="../../assets/images/generating_results/73_1.png">
</div>

این پیمایش کامل، به خصوص زمانی که جداول بزرگ می‌شوند، یک گلوگاه عملکردی بزرگ است.

---

#### **۳. راه‌حل: ایجاد ایندکس روی ستون کلید خارجی**

راه‌حل این مشکل، ایجاد یک ایندکس B-Tree روی ستون کلید خارجی در جدول دیگر است.

```postgresql
CREATE INDEX bookmarks_user_id_idx ON bookmarks(user_id);
```

پس از ایجاد این ایندکس، اگر کوئری `JOIN` را دوباره با `EXPLAIN` اجرا کنیم، می‌بینیم که طرح اجرایی به طور کامل تغییر کرده است. اکنون PostgreSQL برای هر دو جدول از **`Index Scan`** استفاده می‌کند. پیمایش کامل جدول `bookmarks` حذف شده و اتصال به صورت بسیار کارآمد و سریع انجام می‌شود.


<div class='centered-div'>
  <img src="../../assets/images/generating_results/73_2.png">
</div>


---

#### **۴. استفاده از ایندکس ترکیبی برای بهینه‌سازی بیشتر**

شما می‌توانید این استراتژی را یک قدم فراتر برده و از یک **ایندکس ترکیبی (composite index)** استفاده کنید. اگر کوئری `JOIN` شما علاوه بر شرط اتصال، شامل فیلترهای دیگری روی جدول ارجاع دهنده نیز باشد، می‌توانید آن ستون‌ها را نیز به ایندکس اضافه کنید.

مهم است که ستون کلید خارجی (`user_id` در مثال ما) به عنوان **اولین ستون (پیشوند چپ‌ترین)** در تعریف ایندکس ترکیبی قرار گیرد. با این کار، شما هم از مزیت سرعت در `JOIN` و هم از مزیت فیلتر کردن سریع از طریق ایندکس بهره‌مند خواهید شد.

---

#### **۵. جمع‌بندی و توصیه نهایی**

اگر قرار است دو جدول را به هم `JOIN` کنید، تقریباً همیشه ایده بسیار خوبی است که روی ستون **کلید خارجی در جدول فرزند** یک ایندکس (چه به صورت تکی و چه به عنوان بخش اول یک ایندکس ترکیبی) داشته باشید. این کار یکی از ساده‌ترین و مؤثرترین روش‌ها برای بهبود عملکرد کوئری‌های `JOIN` شماست.
