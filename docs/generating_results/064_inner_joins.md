### **جلسه ۶۴: اتصال داخلی (INNER JOIN)**

در جلسه قبل با `CROSS JOIN` که یک اتصال بدون شرط (`unqualified join`) بود، آشنا شدیم. اکنون به سراغ **اتصال‌های شرطی (`qualified join`)** می‌رویم که نوع پیش‌فرض و پرکاربردترین آنها، **اتصال داخلی (INNER JOIN)** است.

---

#### **۱. تعریف و رفتار کلی**

یک `INNER JOIN` دو جدول (یک جدول چپ و یک جدول راست) را بر اساس یک شرط تطابق (`join condition`) که در عبارت `ON` مشخص می‌شود، به هم متصل می‌کند. نتیجه این اتصال، فقط شامل ردیف‌هایی است که در **هر دو جدول** یک مقدار مطابق با شرط داشته باشند. به عبارت دیگر:

- ردیف‌هایی از جدول چپ که هیچ مطابقی در جدول راست ندارند، **حذف می‌شوند**.
- ردیف‌هایی از جدول راست که هیچ مطابقی در جدول چپ ندارند، **حذف می‌شوند**.

این اتصال، ردیف‌های "یتیم" (orphan) را از نتیجه نهایی حذف می‌کند.

---

#### **۲. نوشتار پیش‌فرض: `JOIN` به تنهایی**

در PostgreSQL، کلمه کلیدی `INNER` اختیاری است. نوشتن `JOIN` به تنهایی، معادل `INNER JOIN` است و به عنوان نوع پیش‌فرض اتصال شرطی در نظر گرفته می‌شود.

```postgresql
-- ضمنی
SELECT *
FROM users JOIN bookmarks ON users.id = bookmarks.user_id;

-- صریح
SELECT *
FROM users INNER JOIN bookmarks ON users.id = bookmarks.user_id;
```

---

#### **۳. ابهام‌زدایی ستون‌های هم‌نام**

اگر هر دو جدولی که به هم متصل می‌کنید، ستون‌هایی با نام یکسان داشته باشند (مانند ستون `id` در مثال ما)، شما باید هنگام اشاره به آن ستون‌ها، نام جدول را نیز به عنوان پیشوند ذکر کنید (`users.id` یا `bookmarks.id`).

```postgresql
SELECT users.id, users.first_name, bookmarks.user_id, bookmarks.url
FROM users
JOIN bookmarks ON users.id = bookmarks.user_id
LIMIT 10;
```

در غیر این صورت، PostgreSQL با خطای "ابهام در نام ستون" (ambiguous column) مواجه خواهد شد.

---

#### **۴. بررسی عملی: حذف ردیف‌های بدون تطابق**

برای درک بهتر رفتار `INNER JOIN`، فرض کنید `user_id` یکی از بوکمارک‌ها را به `NULL` تغییر دهیم. از آنجایی که دیگر هیچ کاربری با `id` برابر `NULL` در جدول `users` وجود ندارد، آن بوکمارک دیگر شرط اتصال را برآورده نکرده و از نتیجه نهایی `JOIN` حذف خواهد شد، هرچند که خود ردیف همچنان در جدول `bookmarks` وجود دارد.

```postgresql
UPDATE bookmarks SET user_id = NULL WHERE id = 123;

SELECT users.first_name, bookmarks.url
FROM users
JOIN bookmarks ON users.id = bookmarks.user_id;
```

در خروجی فوق، بوکمارکی که `user_id` آن `NULL` شده است دیگر ظاهر نمی‌شود چون تطابقی در جدول users ندارد.

---

#### **۵. نوشتار جایگزین: استفاده از `USING` برای ستون‌های هم‌نام**

اگر ستون‌هایی که بر اساس آن‌ها `JOIN` را انجام می‌دهید، در **هر دو جدول دقیقاً نام یکسانی** داشته باشند، می‌توانید از یک نوشتار خلاصه‌تر به نام `USING` استفاده کنید.

```postgresql
SELECT *
FROM users JOIN bookmarks USING(user_id)
LIMIT 10;
```

این دستور معادل `ON users.user_id = bookmarks.user_id` است. یک مزیت مهم `USING` این است که در خروجی `* SELECT`، ستون مشترک (`user_id`) فقط **یک بار** نمایش داده می‌شود و از تکرار و ابهام جلوگیری می‌کند.

---

#### **۶. اتصال بر روی چند ستون**

می‌توانید شرط JOIN را بر اساس چند ستون نیز بنویسید؛ به‌شرطی که مقادیر مطابقت داشته باشند. تعداد ستون‌های شرط اهمیتی ندارد تا زمانی که منطق تطابق شما را پوشش دهند.

```postgresql
SELECT *
FROM table_a
JOIN table_b ON table_a.col1 = table_b.col1 AND table_a.col2 = table_b.col2;
```

---

#### **۷. جمع‌بندی**

`INNER JOIN` نوع شرطی و پیش‌فرضِ JOINهای «qualified» است که تنها ردیف‌های دارای تطابق در هر دو سمت را نگه می‌دارد. نگارش `JOIN` به‌تنهایی معادل `INNER JOIN` است، و `USING` یک شورتکات مفید برای ستون‌های دقیقاً هم‌نام فراهم می‌کند که از بازگشت ستون‌های تکراری در `* SELECT` جلوگیری می‌کند.
