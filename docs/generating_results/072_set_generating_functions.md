
### **جلسه ۷۲: توابع مجموعه‌ساز (Set-Returning Functions)**

در ویدیوهای قبل، با تابع `generate_series` آشنا شدیم. ویژگی جالب این تابع این است که به جای بازگرداندن یک مقدار واحد، یک **مجموعه از ردیف‌ها (set of rows)** را برمی‌گرداند. این تابع، عضوی از دسته‌ای از توابع به نام **توابع مجموعه‌ساز (set-returning functions)** است. در این جلسه، با چند نمونه دیگر از این توابع شگفت‌انگیز و کاربردی آشنا می‌شویم.

---

#### **۱. تابع `generate_series`: تولید سری‌های عددی و زمانی**

ما می‌توانیم از `generate_series` برای تولید سری‌های مختلف استفاده کنیم.

- **تولید سری زمانی:** می‌توانیم با مشخص کردن تاریخ شروع، تاریخ پایان و یک گام (step) زمانی، لیستی از تاریخ‌ها را تولید کنیم.
  ```postgresql
  SELECT * 
  FROM generate_series('2024-01-01'::date, '2024-01-10'::date, '3 day');
  ```

- **تولید سری عددی با گام:** می‌توانیم یک سری عددی با یک گام مشخص ایجاد کنیم، برای مثال، تولید تمام اعداد زوج از ۰ تا ۱۰۰.
  ```postgresql
  SELECT * FROM generate_series(0, 100, 2);
  ```

---

#### **۲. تابع `unnest`: تبدیل آرایه به ردیف‌ها**

اگر داده‌های شما در یک ستون از نوع آرایه (`array`) ذخیره شده باشند (مثلاً لیستی از تگ‌ها)، تابع `unnest` می‌تواند آن آرایه را گرفته و هر عنصر آن را به یک **ردیف مجزا** تبدیل کند. این کار به شما اجازه می‌دهد تا روی عناصر آرایه، مانند یک جدول معمولی، کوئری بزنید.

شما همچنین می‌توانید با استفاده از `WITH ORDINALITY`، یک ستون شماره ردیف خودافزا (که از ۱ شروع می‌شود) نیز در کنار نتایج خود داشته باشید. این ویژگی زمانی مفید است که به یک شناسه منحصر به فرد برای ردیف‌های تولید شده نیاز دارید.

```postgresql
SELECT * 
FROM unnest(ARRAY['first', 'second', 'third']) 
WITH ORDINALITY AS t(element, ordinality);
```

---

#### **۳. توابع کار با JSON: تبدیل JSON به مجموعه رکورد**

PostgreSQL توابع قدرتمندی برای تبدیل ساختارهای JSON به مجموعه ردیف‌های قابل کوئری دارد.

**`json_to_recordset` و `jsonb_to_recordset`:** این توابع یک آرایه از اشیاء JSON را دریافت کرده و آن را به یک جدول مجازی تبدیل می‌کنند. شما باید در تعریف خروجی، نام و **نوع داده** هر ستون را مشخص کنید. این یک روش فوق‌العاده برای کار با داده‌های JSON ساختاریافته است.
  
```postgresql
SELECT * 
FROM jsonb_to_recordset('[{"a":1,"b":"foo"}, {"a":"2","b":"bar"}]'::jsonb) AS x(a int, b text);
```

تفاوت اصلی بین این دو تابع این است که یکی با نوع داده `JSON` (متنی) و دیگری با `JSONB` (باینری) کار می‌کند.

---

#### **۴. توابع کار با رشته‌ها و عبارات منظم (Regexp)**

- **`regexp_matches`:** این تابع یک رشته و یک الگوی عبارت منظم (regular expression) را دریافت کرده و تمام بخش‌هایی از رشته را که با الگو مطابقت دارند، به صورت یک مجموعه از ردیف‌ها برمی‌گرداند. شما می‌توانید با استفاده از پرچم `g` (global)، تمام تطابق‌ها را پیدا کنید.
  ```postgresql
  SELECT 
    regexp_matches(
      'The quick brown fox jumps over the lazy dog', '\m\w{4}\M', 'g'
    ) AS m;
  ```

- **`regexp_split_to_table`:** این تابع یک رشته را بر اساس یک الگوی عبارت منظم به بخش‌های مختلف تقسیم کرده و هر بخش را در یک ردیف مجزا قرار می‌دهد.
  ```postgresql
  SELECT regexp_split_to_table('apple,banana,cherry', ',') AS fruit;
  ```

- **`string_to_table`:** این تابع یک رشته را بر اساس یک جداکننده (delimiter) ساده (مانند یک CSV ساده) به ردیف‌های مختلف تقسیم می‌کند.
  ```postgresql
  SELECT string_to_table('apple,banana,cherry', ',') AS fruit;
  ```

!!! tip "گروه‌های کپچر (Capture Groups) در `regexp_matches`"
    شما می‌توانید در الگوی عبارت منظم خود، گروه‌های کپچر تعریف کنید تا بخش‌های خاصی از رشته را استخراج کنید. این تابع به ازای هر تطابق، یک ردیف با ستون‌های متناظر با گروه‌های کپچر شما برمی‌گرداند. این یک روش بسیار قدرتمند برای تجزیه (parse) کردن رشته‌های با فرمت مشخص است.

    ```postgresql
    SELECT 
      regexp_matches('name: Alice, age: 30, name: Bob, age: 25', 'name: (\w+), age: (\d+)', 'g') AS m;
    ```

---

#### **۵. جمع‌بندی**

توابع مجموعه‌ساز، دسته‌ای از توابع در PostgreSQL هستند که به جای یک مقدار واحد، مجموعه‌ای از ردیف‌ها (و گاهی چند ستون) را برمی‌گردانند. این توابع ابزارهای فوق‌العاده قدرتمندی برای تولید داده، تبدیل ساختارهای پیچیده (مانند آرایه و JSON) به فرمت جدولی و تجزیه رشته‌ها هستند و به شما اجازه می‌دهند تا کوئری‌های بسیار پیچیده‌ای را به شکل ساده و کارآمد بنویسید.
