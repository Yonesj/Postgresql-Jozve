### **جلسه ۵۱: ترتیب‌دهی ایندکس (Index Ordering)**

یک نکته بسیار مفید هنگام ایجاد یک ایندکس، به خصوص یک ایندکس ترکیبی، این است که آن را به همان ترتیبی ایجاد کنید که قرار است داده‌ها را بخوانید. اگر شما معمولاً یک ستون خاص را به صورت نزولی (`descending`) مرتب می‌کنید، می‌توانید ایندکس را نیز به همان صورت نزولی ایجاد کنید.

---

#### **۱. ترتیب‌دهی در ایندکس تک ستونی و پیمایش معکوس**

فرض کنید یک ایندکس روی ستون `created_at` ایجاد می‌کنیم. به صورت پیش‌فرض، ایندکس به ترتیب صعودی (`ascending`) ایجاد می‌شود.

- **مرتب‌سازی صعودی:** اگر کوئری `ORDER BY created_at ASC` را اجرا کنیم، `EXPLAIN` نشان می‌دهد که PostgreSQL از **`Index Scan`** استفاده می‌کند، یعنی ایندکس را از ابتدا به انتها می‌خواند.
- **مرتب‌سازی نزولی:** اگر کوئری `ORDER BY created_at DESC` را اجرا کنیم، `EXPLAIN` نشان می‌دهد که PostgreSQL از **`Index Scan Backwards`** استفاده می‌کند.

این رفتار نشان می‌دهد که PostgreSQL به اندازه کافی هوشمند است که بتواند یک ایندکس را هم از ابتدا به انتها و هم از انتها به ابتدا (به صورت معکوس) بخواند. بنابراین، برای یک ایندکس **تک ستونی**، تعیین جهت `ASC` یا `DESC` در زمان ایجاد ایندکس، اهمیت چندانی ندارد.

---

#### **۲. چالش ترتیب‌دهی در ایندکس‌های ترکیبی**

این موضوع زمانی اهمیت پیدا می‌کند که با یک **ایندکس ترکیبی (composite index)** و مرتب‌سازی در جهت‌های مختلف سروکار داریم.

فرض کنید یک ایندکس ترکیبی روی `(birthday, created_at)` ایجاد می‌کنیم (که هر دو به صورت پیش‌فرض صعودی هستند).

- **مرتب‌سازی در جهت یکسان:** اگر کوئری ما `ORDER BY birthday ASC, created_at ASC` یا `ORDER BY birthday DESC, created_at DESC` باشد، PostgreSQL می‌تواند به راحتی از ایندکس (به صورت عادی یا معکوس) استفاده کند و هیچ عملیات مرتب‌سازی اضافی لازم نیست.

- **مرتب‌سازی در جهت‌های مختلف (مشکل اصلی):** اما اگر کوئری ما `ORDER BY birthday DESC, created_at ASC` باشد (یعنی جهت مرتب‌سازی ستون‌ها با جهت تعریف شده در ایندکس متفاوت باشد)، PostgreSQL دیگر نمی‌تواند ایندکس را به صورت بهینه بخواند. در این حالت، `EXPLAIN` نشان می‌دهد که یک عملیات اضافی به نام **`Incremental Sort`** انجام می‌شود. این یعنی PostgreSQL نمی‌تواند بخشی از ایندکس را به جلو و بخش دیگر را به عقب بخواند و مجبور است پس از واکشی داده‌ها، یک مرحله مرتب‌سازی اضافی انجام دهد.

---

#### **۳. راه حل: ایجاد ایندکس با ترتیب دلخواه**

راه حل این مشکل، ایجاد ایندکس دقیقاً به همان ترتیبی است که در کوئری خود نیاز دارید. شما می‌توانید هنگام ایجاد ایندکس، برای هر ستون جهت `ASC` (صعودی) یا `DESC` (نزولی) را مشخص کنید.

```postgresql
CREATE INDEX birthday_created_at ON users (birthday ASC, created_at DESC);
```

پس از ایجاد این ایندکس، اگر کوئری `ORDER BY birthday ASC, created_at DESC` را اجرا کنیم، می‌بینیم که عملیات `Incremental Sort` حذف شده و PostgreSQL می‌تواند مستقیماً از ایندکس برای مرتب‌سازی استفاده کند.

جالب است که حتی با این ایندکس سفارشی، شما همچنان می‌توانید مرتب‌سازی را در جهت **کاملاً معکوس** (`ORDER BY birthday DESC, created_at ASC`) نیز به صورت بهینه انجام دهید، زیرا PostgreSQL کل ایندکس را به صورت معکوس خواهد خواند. مشکل فقط زمانی رخ می‌دهد که جهت‌ها ترکیبی و ناهماهنگ باشند.

---

#### **۴. جمع‌بندی**

برای ایندکس‌های تک ستونی، جهت مرتب‌سازی در زمان ایجاد ایندکس اهمیت زیادی ندارد. اما برای ایندکس‌های ترکیبی، اگر نیاز به مرتب‌سازی ستون‌ها در جهت‌های مختلف دارید، باید ایندکس خود را دقیقاً مطابق با همان ترتیب ایجاد کنید تا از عملیات پرهزینه مرتب‌سازی اضافی جلوگیری کرده و به بهترین عملکرد دست یابید.
