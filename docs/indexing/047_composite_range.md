### **جلسه ۴۷: بازه‌های ترکیبی (Composite Range)**

در جلسه قبل، قانون "از چپ به راست، بدون پرش" را یاد گرفتیم. اکنون به سراغ بخش دوم این قانون طلایی می‌رویم: **"... و در اولین بازه متوقف می‌شود."**

---

#### **۱. مروری بر قانون "توقف در اولین بازه"**

این قانون به این معناست که وقتی PostgreSQL در حال استفاده از یک ایندکس ترکیبی است، به محض برخورد با اولین **شرط بازه‌ای (range condition)**، دیگر نمی‌تواند از ساختار B-Tree برای پیمایش مستقیم (`direct traversal`) ستون‌های بعدی ایندکس استفاده کند و به حالت **اسکن ایندکس (index scan)** تغییر وضعیت می‌دهد.

شروط بازه‌ای شامل اپراتورهایی مانند `>`, `<`, `>=`، `<=` و `BETWEEN` هستند.

---

#### **۲. بررسی عملی با دو ایندکس متفاوت**

برای درک بهتر این موضوع، دو ایندکس ترکیبی مختلف ایجاد می‌کنیم:

1.  `first_last_birth`: روی ستون‌های `(first_name, last_name, birthday)`
2.  `first_birth_last`: روی ستون‌های `(first_name, birthday, last_name)`

سپس کوئری زیر را که شامل دو شرط برابری و یک شرط بازه‌ای است، اجرا می‌کنیم:

```postgresql
WHERE first_name = 'Aaron' AND last_name = 'Francis' AND birthday < '1989-12-31'
```

وقتی این کوئری را با `EXPLAIN` اجرا می‌کنیم، می‌بینیم که PostgreSQL ایندکس اول (`first_last_birth`) را انتخاب می‌کند.

---

#### **۳. چرا ایندکس اول انتخاب شد؟ (شبیه‌سازی رفتار پایگاه داده)**

بیایید نقش پایگاه داده را بازی کنیم تا دلیل این انتخاب را بفهمیم.

**با استفاده از ایندکس `first_last_birth`:**

1.  پایگاه داده می‌تواند با استفاده از شروط برابری روی `first_name` و `last_name`، به صورت کاملاً مستقیم در ساختار B-Tree پیمایش کند و دقیقاً به نقطه‌ای برسد که ردیف‌های مربوط به "Aaron Francis" شروع می‌شوند.
2.  سپس، از آن نقطه به بعد، شروع به **اسکن** گره‌های برگ (leaf nodes) ایندکس می‌کند و تمام ردیف‌هایی را که شرط `'...' > birthday` را برآورده می‌کنند، جمع‌آوری می‌کند.

**با استفاده از ایندکس `first_birth_last`:**

1.  پایگاه داده می‌تواند با استفاده از شرط `first_name`، پیمایش B-Tree را شروع کند.
2.  اما بلافاصله به شرط بازه‌ای روی `birthday` برخورد می‌کند. در این نقطه، پیمایش مستقیم متوقف شده و پایگاه داده مجبور است تمام ردیف‌های مربوط به "Aaron" را که تاریخ تولدشان کمتر از مقدار مشخص شده است، **اسکن** کند.
3.  این اسکن بسیار گسترده‌تر و پرهزینه‌تر از حالت قبل است، زیرا هنوز از شرط `last_name` برای محدود کردن بیشتر نتایج استفاده نکرده است.

به همین دلیل، PostgreSQL هوشمندانه ایندکس اول را انتخاب می‌کند، زیرا دو شرط برابری به آن اجازه می‌دهد تا مجموعه نتایج را به شکل بسیار مؤثرتری محدود کرده و تنها بخش کوچکی از ایندکس را اسکن کند.

---

#### **۴. نتیجه‌گیری عملی و استراتژی طراحی ایندکس**

این رفتار یک نتیجه‌گیری بسیار مهم در طراحی ایندکس‌های ترکیبی برای ما به همراه دارد:

**همیشه ستون‌هایی را که با شروط برابری (`equality conditions`) فیلتر می‌شوند، در سمت چپ تعریف ایندکس قرار دهید و ستون‌هایی را که با شروط بازه‌ای (`range conditions`) فیلتر می‌شوند، در سمت راست آن‌ها قرار دهید.**

این استراتژی به شما کمک می‌کند تا از حداکثر توانایی پیمایش مستقیم B-Tree استفاده کرده و میزان اسکن ایندکس را به حداقل برسانید که این کلید دستیابی به بالاترین عملکرد است.

به یاد داشته باشید که PostgreSQL در مقایسه با برخی پایگاه‌های داده دیگر، انعطاف‌پذیری بیشتری دارد و حتی پس از برخورد با یک شرط بازه‌ای، به استفاده از ایندکس (در حالت اسکن) ادامه می‌دهد. اما برای دستیابی به بهینه‌ترین حالت، رعایت ترتیب "برابری سپس بازه" ضروری است.
