### **جلسه ۴۸: ترکیب چندین ایندکس**

در جلسات قبل، در مورد قدرت ایندکس‌های ترکیبی صحبت کردیم. اما اگر به جای یک ایندکس ترکیبی، چندین ایندکس مجزا داشته باشیم، چه اتفاقی می‌افتد؟ خوشبختانه PostgreSQL در این زمینه نیز قابلیت‌های هوشمندانه‌ای دارد.

---

#### **۱. توانایی PostgreSQL در ترکیب ایندکس‌های مجزا**

اگر شما دو ایندکس مجزا داشته باشید (مثلاً یکی روی `first_name` و دیگری روی `last_name`) و کوئری شما شامل شروطی روی هر دوی این ستون‌ها باشد، PostgreSQL می‌تواند هر دو ایندکس را به صورت جداگانه اسکن کرده و سپس نتایج آن‌ها را با هم ترکیب کند. این روش اگرچه به اندازه یک ایندکس ترکیبی ایده‌آل، کارآمد نیست، اما به مراتب بهتر از پیمایش کامل جدول (`table scan`) است.

---

#### **۲. عملیات BitmapAnd و BitmapOr**

برای درک نحوه ترکیب ایندکس‌ها، `EXPLAIN` را روی یک کوئری با دو شرط بررسی می‌کنیم.

```postgresql
CREATE INDEX "first" ON users (first_name);
CREATE INDEX "last" ON users (last_name);

SELECT FROM users WHERE first_name = 'Aaron' AND last_name = 'Francis';
SELECT FROM users WHERE first_name = 'Aaron' OR last_name = 'Francis';
```

---

در کوئری اول PostgreSQL به صورت زیر عمل می‌کند:

1.  با استفاده از ایندکس `first_name`، یک بیت‌مپ (bitmap) از تمام ردیف‌هایی که شرط اول را برآورده می‌کنند، ایجاد می‌کند.
2.  با استفاده از ایندکس `last_name`، یک بیت‌مپ از تمام ردیف‌هایی که شرط دوم را برآورده می‌کنند، ایجاد می‌کند.
3.  سپس با استفاده از عملیات **`BitmapAnd`** (یک عملیات بیتی `AND`)، اشتراک این دو بیت‌مپ را پیدا می‌کند؛ یعنی ردیف‌هایی که در **هر دو** نتیجه حضور دارند.
4.  در نهایت، به سراغ جدول (heap) رفته و ردیف‌های نهایی را بازیابی می‌کند.

<div class='centered-div'>
  <img src="../../assets/images/indexing/48_1.png">
</div>

---

در کوئری دوم فرآیند مشابه ای رخ می دهد، اما در مرحله سوم از عملیات **`BitmapOr`** استفاده می‌شود تا اجتماع نتایج (ردیف‌هایی که در **حداقل یکی** از نتایج حضور دارند) پیدا شود.

<div class='centered-div'>
  <img src="../../assets/images/indexing/48_2.png">
</div>

---

#### **۳. مقایسه عملکرد: ایندکس ترکیبی در مقابل ترکیب ایندکس‌های مجزا**

سوال اصلی این است که کدام روش بهتر است؟ برای پاسخ به این سوال، یک ایندکس ترکیبی روی `(first_name, last_name)` ایجاد کرده و رفتار PostgreSQL را دوباره بررسی می‌کنیم.

- **برای شرط `AND`:**
  پس از ایجاد ایندکس ترکیبی، PostgreSQL **همیشه ایندکس ترکیبی را انتخاب می‌کند**. دلیل این امر این است که پیمایش یک ساختار B-Tree واحد برای پیدا کردن نتایج دقیق، بسیار سریع‌تر از اسکن دو ایندکس مجزا و سپس ترکیب نتایج آن‌هاست.

- **برای شرط `OR`:**
  جالب است که حتی با وجود ایندکس ترکیبی، PostgreSQL برای شرط `OR` همچنان به سراغ **ترکیب دو ایندکس مجزا با `BitmapOr`** می‌رود. دلیل این امر این است که ساختار B-Tree برای برآورده کردن شرط `OR` بهینه نشده است، اما ترکیب نتایج دو ایندکس مجزا یک راهکار بسیار کارآمد برای این سناریو است.

---

#### **۴. نتیجه‌گیری و استراتژی طراحی**

این مشاهدات یک نتیجه‌گیری بسیار مهم را برای طراحی استراتژی ایندکس‌گذاری ما به همراه دارد:

**هیچ راه‌حل یکسانی برای همه وجود ندارد و شما باید استراتژی ایندکس‌گذاری خود را بر اساس الگوهای دسترسی (access patterns) و کوئری‌های رایج خود بسازید.**

- اگر اکثر کوئری‌های شما از شروط **`AND`** استفاده می‌کنند، یک **ایندکس ترکیبی واحد** تقریباً همیشه بهترین عملکرد را خواهد داشت.
- اگر کوئری‌های با شرط **`OR`** نیز برای شما اهمیت دارند، داشتن **ایندکس‌های مجزا** (که با `BitmapOr` ترکیب شوند) می‌تواند استراتژی بهتری باشد.

قابلیت ترکیب ایندکس‌ها یک ویژگی درجه دو یا فرعی نیست، بلکه یک استراتژی کاملاً معتبر است که می‌توانید در طراحی خود به آن تکیه کنید. اکنون شما با داشتن این دانش، می‌توانید استراتژی‌های مختلف را روی داده‌ها و کوئری‌های واقعی خود تست کرده و بهترین گزینه را انتخاب کنید.
