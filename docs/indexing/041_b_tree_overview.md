### **جلسه ۴۱: نمای کلی B-Tree**

در این جلسه، در دنیای نسبتاً تئوری باقی می‌مانیم تا ببینیم یک **درخت بی (B-tree)** دقیقاً چیست. این رایج‌ترین نوع ایندکس است و برای اکثر کاربردهای معمول مانند جستجو بر اساس برابری مطلق (`strict equality`) یا جستجو در یک محدوده (`ranges`)، عملکرد بسیار سریعی را فراهم می‌کند.

---

#### **۱. سناریو: ایندکس‌گذاری روی یک جدول ساده**

برای درک بهتر، یک جدول ساده `users` با ۱۰ ردیف و ستون‌های `id`، `name` و `email` را در نظر بگیرید. ما قصد داریم روی ستون `name` یک ایندکس از نوع B-Tree ایجاد کرده و سپس فرآیند جستجوی نام "Jennifer" را در این ساختار شبیه‌سازی کنیم.

---

#### **۲. ساختار یک ایندکس B-Tree**

وقتی روی ستون `name` ایندکس می‌سازیم، ساختاری شبیه به یک درخت ایجاد می‌شود. این ساختار از گره‌ها (nodes) تشکیل شده است.

<div class='centered-div'>
  <img src="../../assets/images/indexing/41.png">
</div>

- **گره ریشه (Root Node):** بالاترین گره در درخت است که نقطه شروع هر جستجو محسوب می‌شود. در مثال ما، این گره شامل دو نام "Isaac" و "Steve" است.
- **گره برگ (Leaf Nodes):** پایین‌ترین سطح درخت از گره‌های برگ تشکیل شده است. این گره‌ها بسیار مهم هستند، زیرا **داده‌های واقعی ایندکس شده** (در اینجا، تمام ۱۰ نام به ترتیب حروف الفبا) به همراه **CTID** هر ردیف، در این گره‌ها قرار دارند.
- **گره‌های داخلی (Interior Nodes):** گره‌هایی که بین ریشه و برگ‌ها قرار دارند و به هدایت جستجو به سمت پایین کمک می‌کنند.

نکته کلیدی در مورد داده‌های موجود در گره‌های برگ این است که آن‌ها **کاملاً مرتب شده** هستند.

---

#### **۳. شبیه‌سازی یک جستجو: پیمایش درخت**

حالا بیایید نقش پایگاه داده را بازی کرده و کوئری `;'SELECT * FROM users WHERE name = 'Jennifer` را اجرا کنیم.

1.  **شروع از ریشه:** جستجو همیشه از گره ریشه شروع می‌شود. ما "Jennifer" را با مقادیر گره ریشه ("Isaac" و "Steve") مقایسه می‌کنیم. از آنجایی که "Jennifer" از نظر الفبایی بین این دو نام قرار دارد، مسیر میانی را دنبال می‌کنیم.
2.  **حرکت به گره داخلی:** این مسیر ما را به یک گره داخلی که حاوی نام "Simon" است، می‌رساند. "Jennifer" از "Simon" کوچکتر است، بنابراین مسیر سمت چپ را دنبال می‌کنیم.
3.  **رسیدن به گره برگ:** این مسیر ما را به یک گره برگ می‌رساند. اکنون به جای پیمایش درخت، به سادگی در داخل این گره برگ (که داده‌های مرتبی دارد) به دنبال "Jennifer" می‌گردیم و آن را پیدا می‌کنیم.

یک مثال دیگر، جستجوی "Taylor" است. در گره ریشه، "Taylor" از "Steve" بزرگتر است، پس به سمت راست می‌رویم. در گره بعدی، به گره‌ای می‌رسیم که حاوی "Taylor" است. چون برابر است، باز هم مسیر سمت راست را دنبال کرده و در نهایت در گره برگ، "Taylor" را پیدا می‌کنیم.

---

#### **۴. چرا ایندکس‌ها مهم هستند؟ مقایسه با پیمایش کامل جدول**

هدف یک ایندکس، پیدا کردن سریع داده‌هاست. اگر ایندکس B-Tree وجود نداشت، پایگاه داده برای پیدا کردن "Jennifer" مجبور بود کل جدول را از ابتدا تا انتها پیمایش کند. به این عملیات **پیمایش کامل جدول (table scan)** گفته می‌شود.

- **برای جداول کوچک:** در یک جدول با ۱۰ ردیف، ممکن است پیمایش کامل جدول سریع‌تر از پیمایش ایندکس و سپس مراجعه به جدول باشد.
- **برای جداول بزرگ:** اما در یک جدول با یک میلیارد ردیف، پیمایش کامل جدول فاجعه‌بار است. در مقابل، پیمایش یک درخت B-Tree، حتی برای جداول بسیار بزرگ، تنها نیازمند بازدید از تعداد بسیار کمی از گره‌هاست و به طرز چشمگیری سریع‌تر است.

---

#### **۵. جمع‌بندی**

ساختار B-Tree با مرتب‌سازی داده‌ها و ایجاد یک مسیر پیمایش کارآمد، به پایگاه داده اجازه می‌دهد تا داده‌های مورد نظر را با سرعت فوق‌العاده‌ای پیدا کند. این ساختار زیربنایی، دلیل اصلی کارایی بالای اکثر ایندکس‌ها در PostgreSQL است. درک این ساختار به ما کمک می‌کند تا به صورت شهودی بفهمیم که یک ایندکس در چه شرایطی مفید خواهد بود.
