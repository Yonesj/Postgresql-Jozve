### **جلسه ۴۰: هیپ‌ها و CTIDها (Heaps and CTIDs)**

در جلسه قبل گفتیم که یک ایندکس شامل یک اشاره‌گر (pointer) برای دسترسی به ردیف کامل در جدول است. در این جلسه، می‌خواهیم دقیقاً بررسی کنیم که این اتصال بین ساختار داده مجزای ایندکس و خود جدول چیست و چگونه کار می‌کند.

---

#### **۱. نحوه ذخیره‌سازی ردیف‌ها در PostgreSQL**

برای درک این اتصال، ابتدا باید بدانیم که PostgreSQL چگونه ردیف‌ها را در سطح دیسک ذخیره می‌کند. PostgreSQL داده‌ها را در مجموعه‌ای از **صفحات (pages)** ذخیره می‌کند. این صفحات، بلوک‌هایی با اندازه یکسان هستند و هر ردیف در یک موقعیت مشخص درون یکی از این صفحات قرار می‌گیرد. بنابراین، هر ردیف یک شناسه منحصر به فرد دارد که از دو بخش تشکیل شده است: شماره صفحه و موقعیت ردیف در آن صفحه. برای مثال، `(10, 0)` به معنای ردیف دهم در صفحه صفرم است. این شناسه به PostgreSQL اجازه می‌دهد تا با داشتن آن، مستقیماً به محل فیزیکی ردیف مراجعه کرده و آن را به سرعت بازیابی کند.

ساختاری که ردیف‌ها در آن نوشته می‌شوند، **هیپ (heap)** نام دارد. این نام بسیار مناسب است، زیرا ردیف‌ها دقیقاً مانند یک "توده" یا "انبوهه" در هر کجای خالی که پیدا شود، قرار می‌گیرند. این رویکرد باعث می‌شود عملیات درج (`insert`) بسیار سریع باشد، زیرا PostgreSQL فقط به دنبال اولین فضای خالی برای نوشتن داده می‌گردد.

---

#### **۲. معرفی CTID: شناسه فیزیکی ردیف**

این شناسه فیزیکی که از شماره صفحه و موقعیت ردیف تشکیل شده است، **CTID** نام دارد. CTID یک ستون سیستمی و مخفی در هر جدول است که شما می‌توانید آن را به صورت صریح `SELECT` کنید:

```postgresql
SELECT *, ctid FROM reservations;
```

خروجی این دستور به شما نشان می‌دهد که هر ردیف دقیقاً در کدام صفحه و کدام موقعیت فیزیکی روی دیسک قرار دارد. شما حتی می‌توانید با استفاده از CTID یک ردیف را مستقیماً جستجو کنید:

```postgresql
SELECT *, ctid FROM reservations WHERE ctid='(0,10)';
```

**هشدار بسیار مهم:** هرگز، هرگز و هرگز بر روی CTIDها به عنوان یک شناسه پایدار حساب نکنید و از آن‌ها در اپلیکیشن خود استفاده نکنید. CTIDها **ناپایدار و فرّار (volatile)** هستند و **می‌توانند و تغییر خواهند کرد**. برای مثال، اگر یک ردیف را `UPDATE` کنید و حجم داده‌های آن افزایش یابد، ممکن است PostgreSQL آن را به یک صفحه دیگر با فضای خالی بیشتر منتقل کند و در نتیجه CTID آن تغییر کند. همچنین، فرآیندی به نام `VACUUM` که برای بهینه‌سازی پایگاه داده انجام می‌شود، ردیف‌ها را جابجا کرده و باعث تغییر CTIDها می‌شود. CTIDها کلید اصلی نیستند.

---

#### **۳. ارتباط نهایی: ایندکس‌ها و CTID**

اکنون به نقطه اصلی و نهایی این بحث می‌رسیم. آن "اشاره‌گری" که در جلسه قبل در مورد آن صحبت کردیم، در واقع همان **CTID** است.

**هر ایندکس در PostgreSQL، علاوه بر مقدار ستون ایندکس شده، CTID مربوط به هر ردیف را نیز در خود ذخیره می‌کند.**

این همان حلقه‌ای است که ایندکس را به جدول متصل می‌کند. وقتی PostgreSQL از طریق یک ایندکس یک مقدار را پیدا می‌کند، بلافاصله CTID آن ردیف را نیز به دست می‌آورد و با استفاده از آن، مستقیماً به محل فیزیکی ردیف در هیپ (heap) مراجعه کرده و بقیه داده‌های آن ردیف را بازیابی می‌کند. این مکانیزم، اساس عملکرد سریع جستجوهای مبتنی بر ایندکس در PostgreSQL است.
