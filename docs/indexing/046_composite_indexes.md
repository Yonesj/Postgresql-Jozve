### **جلسه ۴۶: ایندکس‌های ترکیبی (Composite Indexes)**

ایجاد ایندکس روی یک ستون واحد بسیار خوب است، اما قدرت واقعی زمانی آشکار می‌شود که شما یک **ایندکس ترکیبی (composite index)**، یعنی یک ایندکس واحد روی چند ستون به صورت همزمان، ایجاد کنید. به جای ایجاد سه ایندکس مجزا روی سه ستون، ایجاد یک ایندکس ترکیبی روی آن سه ستون می‌تواند عملکرد بسیار بهتری را به همراه داشته باشد.

---

#### **۱. چرا ایندکس ترکیبی بهتر است؟**

اگرچه PostgreSQL قابلیت هوشمندانه‌ای برای اسکن دو ایندکس مجزا و ترکیب نتایج آن‌ها را دارد، اما داشتن یک ایندکس ترکیبی که دقیقاً با کوئری شما مطابقت دارد، همیشه عملکرد بهتری را ارائه می‌دهد، به خصوص زمانی که پای مرتب‌سازی (`sorting`) در میان باشد.

---

#### **۲. قوانین طلایی ایندکس ترکیبی: چپ‌ترین پیشوند (Leftmost Prefix)**

برای استفاده مؤثر از یک ایندکس ترکیبی، باید دو قانون کلیدی را که به مفهوم **چپ‌ترین پیشوند (leftmost prefix)** مربوط می‌شوند، به خاطر بسپارید:

1.  **از چپ به راست، بدون پرش:** شما باید از ستون‌های ایندکس به همان ترتیبی که تعریف شده‌اند (از چپ به راست) در کوئری خود استفاده کنید و نمی‌توانید از روی یک ستون بپرید.
2.  **توقف در اولین بازه:** ایندکس پس از برخورد با اولین شرط بازه‌ای (`range condition` مانند `>`، `<` یا `BETWEEN`)، برای ستون‌های بعدی قابل استفاده نخواهد بود.

---

#### **۳. اهمیت ترتیب ستون‌ها در تعریف ایندکس**

فرض کنید یک ایندکس ترکیبی به این صورت ایجاد می‌کنیم:

```postgresql
CREATE INDEX multi ON users (first_name, last_name, birthday);
```

**ترتیب تعریف این ستون‌ها فوق‌العاده مهم است و در صورتی که در کوئری از روی یک ستون پرش کنیم، ایندکس استفاده نخواهد شد.** اما تا زمانی که این قانون رعایت شود، **ترتیب نوشتن شروط در `WHERE` اهمیتی ندارد**.

- **مثال هایی که قانون را نقض می کنند:** اگر کوئری ما فقط شامل شرط `'...' = WHERE last_name` باشد، ایندکس استفاده **نخواهد شد**. زیرا ما از ستون اول (`first_name`) پریده‌ایم و قانون "پیشوند چپ‌ترین" را نقض کرده‌ایم.

  ```postgresql
  SELECT * FROM users WHERE last_name = 'yabal';
  ```

- **مثال هایی که قانون را رعایت می کنند:** اگر کوئری شامل `'...' = WHERE last_name` باشد، ایندکس استفاده **خواهد شد**. اگر هر دو شرط `first_name` و `last_name` را داشته باشیم، باز هم ایندکس به طور کامل استفاده می‌شود، زیرا از چپ به راست و بدون پرش حرکت کرده‌ایم.

  ```postgresql
  SELECT * FROM users WHERE first_name = 'younes';
  SELECT * FROM users WHERE last_name = 'yabal' AND first_name = 'younes';
  ```

---

#### **۴. یک استثنا و بهینه‌سازی هوشمندانه در PostgreSQL**

حالا یک سناریوی جالب را در نظر بگیرید. با همان ایندکس `(first_name, last_name, birthday)`، کوئری زیر را اجرا می‌کنیم:

```postgresql
SELECT * FROM users WHERE first_name = 'younes' AND birth_day = '2003-05-28';
```

در این کوئری، ما از روی ستون میانی (`last_name`) پریده‌ایم. طبق قانون، ایندکس نباید استفاده شود، اما `EXPLAIN` نشان می‌دهد که ایندکس استفاده **شده است!**

**چه اتفاقی می‌افتد؟**
این یک بهینه‌سازی هوشمندانه در PostgreSQL است. در این حالت، PostgreSQL به صورت زیر عمل می‌کند:

1.  **پیمایش B-Tree:** با استفاده از بخش اول ایندکس (`first_name`)، به سرعت در درخت B-Tree پیمایش کرده و به بخشی از گره‌های برگ (leaf nodes) که مربوط به نام مورد نظر هستند، می‌رسد. این کار مجموعه نتایج را به شدت محدود می‌کند.
2.  **اسکن ایندکس (Index Scan):** سپس، به جای پیمایش کل جدول، فقط همان بخش محدود شده از **ایندکس** را برای پیدا کردن ردیف‌هایی که با شرط `birthday` مطابقت دارند، اسکن می‌کند.

این روش (محدود کردن نتایج با استفاده از ایندکس و سپس اسکن کردن نتیجه محدود شده) به مراتب بهتر از پیمایش کامل جدول (`table scan`) است، اما به خوبیِ یک direct B-tree traversal نیست. پیمایش مستقیم زمانی اتفاق می‌افتد که شما قانون "پیشوند چپ‌ترین" را به طور کامل رعایت کنید.

این رفتار ثابت می‌کند که اگر ایندکس بهتری (مانند ایندکسی فقط روی `first_name` و `birthday`) وجود داشته باشد، PostgreSQL آن را به ایندکس ناقص ترجیح خواهد داد.

```postgresql
CREATE INDEX multi2 ON users (first_name, birthday);
EXPLAIN SELECT * FROM users WHERE first_name = 'younes' AND birth_day = '2003-05-28';
-- Index scan using multi2 on users ...
```

---

#### **۵. نتیجه‌گیری عملی**

- **مهم‌ترین شروط در سمت چپ:** ستون‌هایی که در اکثر کوئری‌های شما وجود دارند، باید در **سمت چپ** تعریف ایندکس ترکیبی قرار بگیرند.
- **شروط برابری قبل از شروط بازه‌ای:** ستون‌هایی که با شرط برابری (`=`) فیلتر می‌شوند، باید قبل از ستون‌هایی که با شروط بازه‌ای فیلتر می‌شوند، در تعریف ایندکس قرار بگیرند (این موضوع در جلسه بعد بررسی خواهد شد).

رعایت این نکات به شما کمک می‌کند تا پیمایش‌های مستقیم B-Tree بیشتری داشته باشید و از اسکن‌های پرهزینه (چه اسکن جدول و چه اسکن بخش بزرگی از ایندکس) جلوگیری کنید.
