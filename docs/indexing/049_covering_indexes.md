### **جلسه ۴۹: ایندکس‌های پوششی (Covering Indexes)**

تا به اینجا، در تمام سناریوهای ایندکس‌گذاری، داستان یکسان بوده است: ما از یک ایندکس برای پیدا کردن آدرس ردیف‌ها استفاده کرده، سپس به جدول اصلی (heap) مراجعه کرده و ردیف کامل را بازیابی می‌کنیم. اما یک حالت بسیار خاص و فوق‌العاده سریع وجود دارد که در آن، نیازی به این مراجعه به جدول اصلی نیست و تمام نیازهای کوئری مستقیماً از خود ایندکس برآورده می‌شود. به این حالت، **ایندکس پوششی (Covering Index)** گفته می‌شود.

---

#### **۱. ایندکس پوششی چیست؟**

یک ایندکس پوششی زمانی اتفاق می‌افتد که **تمام اطلاعات مورد نیاز یک کوئری**، شامل ستون‌های موجود در `SELECT`، `WHERE`، `ORDER BY` و `GROUP BY`، همگی در داخل خود ایندکس وجود داشته باشند. در این حالت، PostgreSQL دیگر به جدول اصلی مراجعه نمی‌کند و پاسخ را مستقیماً از ایندکس برمی‌گرداند.

برای شناسایی این حالت، باید در خروجی `EXPLAIN` به دنبال عبارت **`Index Only Scan`** بگردید. برای مثال اگر یک ایندکس روی ستون `first_name` داشته باشیم:

- کوئری `'...' = SELECT * FROM users WHERE first_name` از `Index Scan` معمولی استفاده می‌کند، زیرا باید برای ستون‌های دیگر به جدول مراجعه کند.
- کوئری `'...' = SELECT first_name FROM users WHERE first_name` از **`Index Only Scan`** استفاده می‌کند، زیرا هم شرط `WHERE` و هم ستون `SELECT` شده، هر دو در ایندکس وجود دارند.

یک ایندکس پوششی یک نوع خاص از ایندکس نیست، بلکه یک **ایندکس معمولی در یک موقعیت خاص** است. اینکه یک ایندکس به عنوان پوششی عمل کند یا نه، کاملاً به کوئری شما بستگی دارد.

---

#### **۲. افزودن داده‌های اضافی به ایندکس با `INCLUDE`**

گاهی اوقات شما می‌خواهید یک ستون در نتایج کوئری شما باشد تا از مزایای ایندکس پوششی بهره‌مند شوید، اما نمی‌خواهید آن ستون بخشی از منطق جستجوی B-Tree باشد. در PostgreSQL، برای این کار می‌توانید از عبارت **`INCLUDE`** در تعریف ایندکس خود استفاده کنید.

```postgresql
CREATE INDEX multi ON users (first_name, last_name) INCLUDE (id);
```

این دستور یک ایندکس ترکیبی روی `first_name` و `last_name` ایجاد می‌کند، اما علاوه بر آن، مقدار ستون `id` را نیز به عنوان یک "بار اضافی" در گره‌های برگ (leaf nodes) ایندکس ذخیره می‌کند. ستون `id` در فرآیند پیمایش B-Tree نقشی ندارد، اما پس از پیدا شدن ردیف‌های مورد نظر، مقدار آن مستقیماً از ایندکس قابل خواندن است.

با این ایندکس، کوئری `... SELECT id, first_name, last_name FROM users WHERE` می‌تواند به صورت `Index Only Scan` اجرا شود.

---

#### **۳. معایب و ملاحظات در استفاده از ایندکس‌های پوششی**

اگرچه ایندکس‌های پوششی بسیار سریع هستند، اما نباید استراتژی اصلی شما باشند و باید با احتیاط از آن‌ها استفاده کرد.

- **تورم ایندکس (Index Bloat):** افزودن ستون‌های زیاد به بخش `INCLUDE` (به خصوص ستون‌های بزرگ مانند `text` یا `JSON`) باعث حجیم شدن شدید ساختار B-Tree و افزایش فضای مصرفی می‌شود. در واقع شما در حال کپی کردن بخش بزرگی از جدول خود در داخل ایندکس هستید.

- **چالش همزمانی و نقشه رؤیت‌پذیری (Visibility Map):** به دلیل مکانیزم کنترل همزمانی در PostgreSQL (MVCC)، حتی در یک `Index Only Scan`، پایگاه داده باید بررسی کند که آیا ردیف‌های پیدا شده در ایندکس، برای تراکنش فعلی **قابل رؤیت (visible)** هستند یا خیر. برای این کار، PostgreSQL به یک ساختار داده به نام **نقشه رؤیت‌پذیری (visibility map)** مراجعه می‌کند. اگر جدول شما به طور مداوم در حال تغییر (`UPDATE`, `INSERT`, `DELETE`) باشد، این نقشه ممکن است به‌روز نباشد و PostgreSQL مجبور شود برای اطمینان از رؤیت‌پذیری، **در هر صورت به جدول اصلی (heap) مراجعه کند**. این کار عملاً مزیت ایندکس پوششی را از بین می‌برد.

**اصل مهم: فقط ستون‌های مورد نیاز را `SELECT` کنید.** این موضوع اهمیت این اصل قدیمی را یادآوری می‌کند. اگر همیشه به جای انتخاب ستون‌های مشخص، از `* SELECT` استفاده کنید، تقریباً هیچ‌وقت شانس استفاده از یک ایندکس پوششی را نخواهید داشت.

---

#### **۴. جمع‌بندی**

ایندکس‌های پوششی در شرایط مناسب، سریع‌ترین نوع دسترسی به داده‌ها هستند، زیرا نیاز به مراجعه به جدول اصلی را حذف می‌کنند. آن‌ها برای جداولی که به ندرت تغییر می‌کنند و برای کوئری‌های بسیار خاص و پرتکرار (hot paths) می‌توانند یک بهبود عملکرد فوق‌العاده باشند. با این حال، به دلیل چالش‌های مربوط به حجم ایندکس و نقشه رؤیت‌پذیری، نباید استراتژی اصلی ایندکس‌گذاری خود را بر پایه آن‌ها بنا کنید.
