### **جلسه ۴۵: گزینش‌پذیری ایندکس (Index Selectivity)**

هنگامی که می‌خواهیم یک ایندکس ایجاد کنیم، باید بررسی کنیم که آیا ستون مورد نظر، کاندیدای خوبی برای ایندکس‌گذاری است یا خیر. برخلاف طراحی اسکیما، برای این کار نمی‌توانیم فقط به داده‌ها نگاه کنیم؛ باید به کوئری‌ها نیز توجه کنیم. با این حال، با تحلیل داده‌ها می‌توانیم مشخص کنیم که آیا یک ستون پتانسیل خوبی برای ایندکس شدن دارد یا نه.

---

#### **۱. مفاهیم کلیدی: کاردینالیتی و گزینش‌پذیری**

برای تعیین اینکه آیا یک ستون کاندیدای خوبی برای ایندکس‌گذاری است، باید با دو مفهوم کلیدی آشنا شویم.

- **کاردینالیتی (Cardinality):** این مفهوم به سادگی به **تعداد مقادیر متمایز (distinct)** در یک ستون اشاره دارد. برای مثال، یک ستون بولین (`Boolean`) که فقط می‌تواند `true` یا `false` باشد، کاردینالیتی برابر با ۲ دارد. کاردینالیتی به تنهایی معیار خوبی نیست. در یک جدول با دو ردیف، کاردینالیتی ۲ عالی است، اما در یک جدول با یک میلیون ردیف، این کاردینالیتی پایین به این معناست که ایندکس نمی‌تواند داده‌ها را به خوبی فیلتر کند.

- **گزینش‌پذیری (Selectivity):** این مفهوم یک **نسبت** است و به صورت زیر محاسبه می‌شود:
  ```
  (تعداد مقادیر متمایز) / (تعداد کل ردیف‌ها)
  ```
  این نسبت به ما می‌گوید که یک ایندکس چقدر در فیلتر کردن و محدود کردن ردیف‌ها مؤثر است.

---

#### **۲. تحلیل گزینش‌پذیری در عمل**

مقدار گزینش‌پذیری عددی بین ۰ و ۱ است. هرچه این عدد به **یک** نزدیک‌تر باشد، گزینش‌پذیری بالاتر و ایندکس کارآمدتر است.

- **بهترین حالت (گزینش‌پذیری ۱):** ستون کلید اصلی (`id`) بالاترین گزینش‌پذیری ممکن را دارد. از آنجایی که هر مقدار در این ستون منحصر به فرد است، تعداد مقادیر متمایز برابر با تعداد کل ردیف‌هاست و گزینش‌پذیری آن برابر با **یک** است. ایندکس روی چنین ستونی می‌تواند شما را مستقیماً به یک ردیف واحد برساند.

- **بدترین حالت (گزینش‌پذیری نزدیک به صفر):** یک ستون بولین مانند `is_pro` در یک جدول بزرگ، گزینش‌پذیری بسیار پایینی دارد، زیرا تنها دو مقدار متمایز در میان میلیون‌ها ردیف وجود دارد.

```postgresql
SELECT
	COUNT(id)::DECIMAL / COUNT(*)::DECIMAL
FROM
	users; -- output: 1.00000000

SELECT
	COUNT(DISTINCT is_pro)::DECIMAL / COUNT(*)::DECIMAL
FROM
	users; -- output: 0.00000202
```

---

#### **۳. اهمیت توزیع داده (Data Skew)**

آیا گزینش‌پذیری پایین یک ستون به این معناست که هرگز نباید روی آن ایندکس بسازیم؟ **خیر!** اینجا جایی است که **توزیع داده (data distribution)** یا **چولگی داده (data skew)** اهمیت پیدا می‌کند. ممکن است یک ستون در کل گزینش‌پذیری پایینی داشته باشد، اما اگر داده‌های آن به شدت چوله باشند و شما اغلب به دنبال بخش کوچک‌تر و نادرتر داده‌ها باشید، ایندکس می‌تواند فوق‌العاده مفید باشد. برای مثال، در جدول `users` ما، از یک میلیون کاربر، تنها ۴۴,۰۰۰ نفر کاربر حرفه‌ای (`is_pro = true`) هستند.

```postgresql
SELECT COUNT(*) FILTER(WHERE is_pro IS TRUE) FROM users; -- output: 44382
```

اگر کوئری رایج ما جستجوی کاربران حرفه‌ای باشد، یک ایندکس روی ستون `is_pro` می‌تواند PostgreSQL را به سرعت به آن ۴.۴ درصد از ردیف‌ها برساند و از پیمایش ۹۵.۶ درصد دیگر جدول جلوگیری کند.

بنابراین، علاوه بر گزینش‌پذیری کلی ستون، باید به گزینش‌پذیری **کوئری‌های خاص** خود نیز توجه کنید.

---

#### **۴. گزینش‌پذیری در کوئری‌های بازه‌ای و تصمیم‌گیری PostgreSQL**

در جلسه قبل دیدیم که کوئری `'...' > WHERE birthday` از ایندکس استفاده کرد، اما `'...' < WHERE birthday` از آن استفاده نکرد. دلیل این امر به گزینش‌پذیری آن کوئری خاص برمی‌گردد.

- در حالت اول (`>`)، تعداد ردیف‌های بازگشتی کمتر از نیمی از جدول بود و PostgreSQL تشخیص داد که استفاده از ایندکس به صرفه است.
- در حالت دوم (`<`)، تعداد ردیف‌های بازگشتی بیش از نیمی از جدول بود. در چنین شرایطی، PostgreSQL به این نتیجه می‌رسد که پیمایش ایندکس و سپس مراجعه مکرر به جدول (heap) برای هر ردیف، از پیمایش مستقیم و یکجای کل جدول پرهزینه‌تر است و بنابراین ایندکس را نادیده می‌گیرد.

```postgresql
SELECT COUNT(*) FROM users WHERE birthday < '1989-02-14'; -- 417k
SELECT COUNT(*) FROM users WHERE birthday > '1989-02-14'; -- 572k
```

**قانون کلی:** شما می‌خواهید که ایندکس به شما کمک کند تا در سریع‌ترین زمان ممکن، به **تعداد کمی از ردیف‌ها** برسید.

---

#### **۵. آمار پایگاه داده و دستور `ANALYZE`**

PostgreSQL برای تصمیم‌گیری در مورد استفاده یا عدم استفاده از یک ایندکس، کوئری‌ها را به صورت زنده اجرا نمی‌کند. در عوض، به **آمارهای (statistics)** داخلی که در مورد توزیع داده‌ها در جداول نگهداری می‌کند، مراجعه می‌کند. این آمارها توسط فرآیند `autovacuum` به صورت خودکار به‌روزرسانی می‌شوند. اما اگر شما تغییرات بزرگی (مانند `INSERT` یا `DELETE` میلیونی) در جدول ایجاد کنید، ممکن است نیاز باشد تا با اجرای دستی دستور `ANALYZE`، این آمارها را به‌روز کنید تا PostgreSQL بتواند تصمیمات بهینه‌تری بگیرد.
