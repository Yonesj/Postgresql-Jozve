### **جلسه ۴۴: کجا ایندکس اضافه کنیم؟**

پس از یادگیری تئوری ایندکس‌ها، اکنون زمان آن رسیده که به صورت عملی با آن‌ها کار کنیم. در این جلسه، به این سوال مهم پاسخ می‌دهیم که در چه شرایطی و روی چه ستون‌هایی باید ایندکس بسازیم.

---

#### **۱. ایندکس‌گذاری: هنر است، نه علم**

برخلاف طراحی اسکیما که تا حد زیادی یک فرآیند علمی و مبتنی بر تحلیل داده‌هاست، ایندکس‌گذاری بیشتر شبیه به یک **هنر** است. شما نمی‌توانید صرفاً با نگاه کردن به داده‌ها یا اسکیما، ایندکس‌های مناسب را استنتاج کنید. کلید اصلی در طراحی یک استراتژی ایندکس-گذاری مؤثر، بررسی **الگوهای دسترسی (access patterns)** شماست. به عبارت دیگر، شما باید ببینید که **چگونه قرار است روی جداول خود کوئری بزنید**.

---

#### **۲. اشتباهات رایج در ایندکس‌گذاری**

- **ایندکس‌گذاری روی تمام ستون‌ها:** این یک ایده بسیار بد است. به یاد داشته باشید که هر ایندکس یک ساختار داده مجزاست که کپی‌ای از داده‌ها را نگهداری می‌کند. ایندکس‌گذاری روی تمام ستون‌ها عملاً به معنای دو برابر کردن حجم داده‌های شماست و باعث کند شدن شدید عملیات درج، به‌روزرسانی و حذف (`INSERT`, `UPDATE`, `DELETE`) می‌شود، زیرا تمام ایندکس‌ها باید نگهداری شوند. حتی عملکرد خواندن (`SELECT`) نیز ممکن است آنگونه که فکر می کنید بهینه نباشد، زیرا اغلب یک ایندکس ترکیبی (composite index) روی چند ستون، بهتر از چند ایندکس مجزا عمل می‌کند.

- **ایندکس‌گذاری فقط روی ستون‌های `WHERE`:** این یک قانون سرانگشتی بهتر، اما همچنان ناقص است. یک رویکرد حرفه‌ای-تر، در نظر گرفتن **تمام بخش‌های یک کوئری** است. شما باید علاوه بر `WHERE`، به بخش‌های `ORDER BY`، `GROUP BY`، `JOIN` و حتی `SELECT` نیز توجه کنید.

---

#### **۳. بررسی عملی کاربرد ایندکس B-Tree**

برای بررسی عملی، از یک جدول `users` با حدود یک میلیون ردیف استفاده می‌کنیم. ابتدا یک کوئری روی جدول (قبل ایندکس گذاری) می زنیم تا نتیجه آن را بتوانیم مقایسه کنیم.

```postgresql
EXPLAIN SELECT FROM users WHERE birthday = '1989-02-14';
```

<div class='centered-div'>
  <img src="../../assets/images/indexing/44_1.png">
</div>

سپس یک ایندکس B-Tree ساده روی ستون `birthday` ایجاد می‌کنیم:

```postgresql
CREATE INDEX bday ON users USING btree (birthday);
```

سپس با استفاده از دستور `EXPLAIN`، تأثیر این ایندکس را بر انواع مختلف کوئری‌ها بررسی می‌کنیم.

---

**تأثیر بر برابری مطلق (Strict Equality):**
یک کوئری با شرط `'...' = WHERE birthday`، قبل از ایجاد ایندکس از **پیمایش کامل و موازی جدول (Parallel Seq Scan)** استفاده می‌کند. اما پس از ایجاد ایندکس، PostgreSQL به سراغ **پیمایش ایندکس (Bitmap Index Scan)** می‌رود که به مراتب سریع‌تر است.

<div class='centered-div'>
  <img src="../../assets/images/indexing/44_2.png">
</div>

---

**تأثیر بر محدوده‌های باز (Unbounded Ranges):**
یک کوئری با شرط `'...' > WHERE birthday` نیز از ایندکس استفاده می‌کند.

<div class='centered-div'>
  <img src="../../assets/images/indexing/44_3.png">
</div>

اما جالب است که یک کوئری با شرط `'...' < WHERE birthday` ممکن است دوباره به پیمایش کامل جدول بازگردد. دلیل این امر به مفهومی به نام **گزینش‌پذیری ایندکس (index selectivity)** مربوط است که در جلسه بعد به آن خواهیم پرداخت.

<div class='centered-div'>
  <img src="../../assets/images/indexing/44_4.png">
</div>

---

**تأثیر بر محدوده‌های بسته (Bounded Ranges):**
کوئری هایی به این شکل نیز به خوبی از ایندکس استفاده می‌کند.

```postgresql
SELECT FROM users WHERE birthday BETWEEN '...' AND '...';
```

<div class='centered-div'>
  <img src="../../assets/images/indexing/44_5.png">
</div>

---

**تأثیر بر مرتب‌سازی (Ordering):**
یک کوئری با `ORDER BY birthday`، با وجود ایندکس، می‌تواند از **پیمایش ایندکس (Index Scan)** استفاده کند. مزیت بزرگ این کار این است که داده‌ها در ایندکس از قبل مرتب شده‌اند. بنابراین، پایگاه داده نیازی به عملیات پرهزینه مرتب-سازی (`Sort`) ندارد و می‌تواند داده‌ها را مستقیماً به ترتیب از روی ایندکس بخواند.

---

**تأثیر بر گروه‌بندی (Grouping):**
یک کوئری با `GROUP BY birthday` نیز از ایندکس بهره‌مند می‌شود و به جای پیمایش کامل جدول، از پیمایش ایندکس برای گروه‌بندی داده‌ها استفاده می‌کند که بسیار کارآمدتر است.

---

#### **۴. جمع‌بندی**

در این جلسه به صورت عملی ثابت کردیم که یک ایندکس ساده B-Tree می‌تواند عملکرد کوئری‌های مبتنی بر برابری مطلق، محدوده‌ها، مرتب‌سازی و گروه‌بندی را به طرز چشمگیری بهبود بخشد. این جلسه یک شروع سریع برای ورود به دنیای ایندکس‌های B-Tree بود. در جلسات آینده، به مفاهیم پیشرفته‌تری مانند گزینش‌پذیری، ایندکس‌های ترکیبی و موارد دیگر خواهیم پرداخت.
