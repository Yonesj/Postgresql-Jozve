### **جلسه ۴۳: انواع کلید اصلی**

این جلسه به بررسی و مقایسه انواع داده مختلف برای کلیدهای اصلی (primary keys) اختصاص دارد. این بحث را می‌توان به دو دسته اصلی تقسیم کرد: استفاده از اعداد صحیح (integers) در مقابل استفاده از شناسه‌های منحصر به فرد جهانی (UUIDs).

---

#### **۱. گزینه اول و پیشنهادی: اعداد صحیح بزرگ (`BIGINT`)**

نظر مدرس این است که در **۹۸ درصد موارد**، استفاده از انواع داده عددی، به خصوص **`BIGINT`**، بهترین انتخاب برای کلید اصلی است.

- **چرا `BIGINT`؟**
  شاید این توصیه با اصلی که قبلاً یاد گرفتیم (انتخاب کوچکترین دیتا تایپ ممکن) در تضاد به نظر برسد. اما کلیدهای اصلی یک استثنا هستند. بزرگترین خطر برای یک کلید اصلی، **تمام شدن فضای آن** است. این اتفاق در اوج موفقیت یک پروژه می‌تواند یک فاجعه باشد و برای شرکت‌های بزرگی مانند Basecamp نیز رخ داده است. بنابراین، بهتر است با پذیرفتن هزینه ناچیز فضای ذخیره‌سازی بیشتر، از آرامش خاطر ناشی از داشتن یک فضای تقریباً نامحدود برای شناسه‌ها بهره‌مند شویم.

- **روش تعریف پیشنهادی:**
  `id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY`
  این روش مدرن، امن و بسیار کارآمد برای تعریف یک کلید اصلی خودافزا است.

---

#### **۲. گزینه دوم: شناسه‌های منحصر به فرد جهانی (UUIDs)**

UUIDها در سناریوهای خاصی بسیار ارزشمند هستند، اما استفاده از آن‌ها به عنوان کلید اصلی، چالش‌هایی را به همراه دارد.
باید بدانیم که UUIDها انواع (variants) مختلفی دارند. نوعی از UUID که به صورت پیش‌فرض در PostgreSQL با تابع `()gen_random_uuid` تولید می‌شود، **کاملاً تصادفی** است. علاوه بر این، شناسه‌های دیگری مانند ULID نیز وجود دارند که قابلیت مرتب‌سازی دارند.

**چالش اصلی UUIDهای تصادفی: شکستن و بازآرایی B-Tree**

مشکل اصلی UUIDهای کاملاً تصادفی، نحوه درج آن‌ها در ایندکس B-Tree است. از آنجایی که این شناسه‌ها هیچ ترتیب مشخصی ندارند، هر `INSERT` جدید ممکن است در یک نقطه کاملاً تصادفی از گره‌های برگ (leaf nodes) ایندکس قرار گیرد. این کار باعث می‌شود که ساختار B-Tree به طور مداوم دچار شکست (fracture) شده و نیاز به بازآرایی و متعادل‌سازی (rebalance) داشته باشد که این خود هزینه‌بر است. در مقابل، شناسه‌های عددی خودافزا همیشه در انتهای ایندکس درج می‌شوند و ساختار درخت را متعادل نگه می‌دارند.

**راه حل: UUIDهای مرتب‌شده بر اساس زمان**

برای حل این مشکل، باید از انواع UUID استفاده کرد که بر اساس زمان مرتب می‌شوند، مانند **UUIDv7** یا شناسه‌های **ULID**. در این نوع شناسه‌ها، بخش ابتدایی شناسه به مهر زمانی اختصاص دارد که باعث می‌شود درج‌ها همیشه به صورت افزایشی و در انتهای ایندکس انجام شوند و مشکل شکستن B-Tree از بین برود.

---

#### **۳. چه زمانی واقعاً به UUID نیاز داریم؟**

مزیت اصلی و دلیل واقعی استفاده از UUID یا ULID، قابلیت **تولید شناسه بدون هماهنگی مرکزی و بدون نیاز به ارتباط با پایگاه داده** است. این ویژگی در سناریوهایی مانند سیستم‌های توزیع‌شده یا رابط‌های کاربری خوش‌بینانه (optimistic UI) که در آن شناسه باید در سمت کلاینت و قبل از ارسال به دیتابیس ایجاد شود، حیاتی است.

---

#### **۴. نگرانی امنیتی و راه حل کلید ثانویه**

یک نقد رایج به کلیدهای اصلی عددی، **ریسک امنیتی** ناشی از قابل پیش‌بینی بودن آن‌هاست. قرار دادن یک شناسه عددی خودافزا در URL می‌تواند اطلاعاتی مانند تعداد کاربران یا تعداد فاکتورهای یک سیستم را فاش کند.

این یک نگرانی معتبر است، اما راه حل آن استفاده نکردن از کلید اصلی عددی نیست. راه حل بهتر، ایجاد یک **کلید عمومی ثانویه (public secondary key)** در کنار کلید اصلی `BIGINT` است. شما می‌توانید با استفاده از کتابخانه‌هایی مانند Nano ID، یک شناسه تصادفی، فشرده و غیرقابل حدس ایجاد کرده و از آن در URLها یا APIهای عمومی خود استفاده کنید. در داخل سیستم، شما همچنان از تمام مزایای کلید اصلی `BIGINT` خود برای `JOIN`ها و روابط داخلی بهره‌مند خواهید شد.

---

#### **۵. جمع‌بندی و توصیه‌ها**

- **`BIGINT` را ترجیح دهید**، مگر اینکه دلیل بسیار خوبی برای استفاده نکردن از آن داشته باشید.
- اگر مجبور به استفاده از UUID هستید، حتماً از یک **نوع مرتب‌شده بر اساس زمان** (مانند UUIDv7 یا ULID) استفاده کنید.
- اگر نگران افشای شناسه‌های عددی هستید، از یک **کلید ثانویه عمومی** (مانند Nano ID) در کنار کلید اصلی خود استفاده کنید.
