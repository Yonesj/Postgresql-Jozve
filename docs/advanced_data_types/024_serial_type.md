### **جلسه 24: نوع داده سریال (SERIAL)**

نوع داده `SERIAL` در واقع یک نوع داده **واقعی** نیست. این یک نام مستعار (alias) است که علاوه بر ایجاد یک ستون از نوع عدد صحیح، کارهای دیگری را نیز در پس‌زمینه انجام می‌دهد.

---

#### **۱. `SERIAL` و کلیدهای اصلی: یک هشدار مهم**

`SERIAL` اغلب برای ایجاد کلیدهای اصلی (Primary Key) خودافزا (auto-incrementing) استفاده می‌شود. این روش تا قبل از نسخه ۱۰ PostgreSQL، روش استاندارد و مورد تایید بود. اما **از PostgreSQL نسخه ۱۰ به بعد، روش بهتری** برای ایجاد کلیدهای اصلی خودافزا وجود دارد که در جلسه مربوط به `IDENTITY` به آن خواهیم پرداخت. روش جدیدتر ساده‌تر است و مشکلات کمتری در زمینه مجوزها (permissions) دارد. با این حال، `SERIAL` هنوز وجود دارد و قابل استفاده است و درک نحوه کار آن مهم است.

---

#### **۲. `SERIAL` در پس‌زمینه چه کاری انجام می‌دهد؟**

وقتی شما یک ستون را به عنوان `SERIAL` تعریف می‌کنید، این کلمه کلیدی در واقع به مجموعه‌ای از دستورات تبدیل می‌شود:

1.  **ایجاد یک دنباله (Sequence):** یک شیء جداگانه به نام دنباله (Sequence) ایجاد می‌شود که وظیفه تولید اعداد متوالی را بر عهده دارد.
2.  **تعریف ستون به عنوان `INTEGER`:** ستون شما از نوع داده واقعی `INTEGER` ایجاد می‌شود.
3.  **تنظیم به عنوان `NOT NULL`:** این ستون به صورت خودکار `NOT NULL` تعریف می‌شود.
4.  **تعیین مقدار پیش‌فرض:** مقدار پیش‌فرض ستون به گونه‌ای تنظیم می‌شود که در هر بار درج، مقدار بعدی را از دنباله ایجاد شده فراخوانی کند (با استفاده از `nextval`). این همان چیزی است که باعث خودافزا شدن می‌شود.
5.  **ایجاد مالکیت:** دنباله ایجاد شده به عنوان "متعلق" به این ستون و جدول تعریف می‌شود تا در صورت حذف جدول یا ستون، دنباله نیز به صورت خودکار حذف شود.

```postgresql
-- this
CREATE TABLE serial_example(
	id SERIAL
);
-- turns into something like this
CREATE SEQUENCE serial_example_id_seq AS INTEGER;
CREATE TABLE serial_example(
	id INTEGER NOT NULL nextval('serial_example_id_seq')
);
ALTER SEQUENCE serial_example_id_seq OWNED BY serial_example;
```

---

#### **۳. توصیه مهم: استفاده از `BIGSERIAL` به جای `SERIAL`**

اگر به هر دلیلی تصمیم به استفاده از این روش برای کلیدهای اصلی گرفتید، به جای `SERIAL` از **`BIGSERIAL`** استفاده کنید. `BIGSERIAL` در پس‌زمینه یک ستون از نوع `BIGINT` (big integer) ایجاد می‌کند.

```postgresql
CREATE TABLE serial_example(
	id BIGSERIAL PRIMARY KEY
);
```

این تنها جایی است که باید قانون "انتخاب کوچکترین نوع داده" را نادیده بگیرید. هرگز نباید فضای کلیدهای اصلی شما تمام شود. این یک فاجعه است که برای شرکت‌های بزرگی مانند Basecamp نیز رخ داده است. بنابراین، برای کلیدهای اصلی همیشه دست و دلباز باشید و از `BIGINT` استفاده کنید تا با رشد داده‌ها به مشکل برنخورید.

---

#### **۴. چرا در دنباله‌ها شکاف (Gap) ایجاد می‌شود؟**

در مقادیر تولید شده توسط یک دنباله ممکن است شکاف ایجاد شود (مثلاً ۱، ۲، ۳، ۴، ۶) و این کاملاً **طبیعی و خوب** است. دلیل این امر این است که فراخوانی تابع `nextval` به صورت آگاه از تراکنش (transaction-aware) عمل **نمی‌کند**.

این رفتار یک مزیت است. تصور کنید دو تراکنش همزمان مقدار `5` را از دنباله دریافت کنند. در این صورت، هنگام `commit` کردن، با خطای کلید تکراری مواجه خواهید شد. برای جلوگیری از این مشکل، وقتی یک تراکنش `nextval` را فراخوانی می‌کند، شمارنده دنباله به جلو حرکت می‌کند. حال اگر آن تراکنش به هر دلیلی `rollback` شود یا شکست بخورد، مقداری که دریافت کرده بود (مثلاً `5`) هرگز به دنباله بازگردانده نمی‌شود و برای همیشه از بین می‌رود. این کار جلوی بن‌بست‌ها و خطاهای تکراری را می‌گیرد.

بنابراین، اگر به یک دنباله کاملاً بدون شکاف نیاز دارید، `SERIAL` برای شما مناسب نیست و باید راهکار خود را پیاده‌سازی کنید.

---

#### **۵. کاربردهای دیگر `SERIAL` و نکته پایانی در مورد کلید اصلی**

علاوه بر کلید اصلی، می‌توانید از `SERIAL` برای تولید مقادیر خودافزای دیگر مانند شماره سفارش (`order_number`) استفاده کنید. اگر از `BIGSERIAL` به عنوان کلید اصلی استفاده می‌کنید، حتماً آن را با کلمه کلیدی `PRIMARY KEY` مشخص کنید. این کار جلوی درج مقادیر تکراری را می‌گیرد، زیرا اگرچه خود دنباله مقدار تکراری تولید نمی‌کند، اما شما می‌توانید به صورت دستی یک مقدار را `INSERT` کنید که ممکن است تکراری باشد.

```postgresql
CREATE TABLE orders (
	id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
	order_number SERIAL,
	customer_name VARCHAR(128),
	order_date DATE,
	total_amount NUMBER(10, 2)
);
```

---

#### **۶. بازگرداندن مقادیر خودافزا با کلمه کلیدی `RETURNING`**

یک مشکل رایج این است که پس از درج یک ردیف، برای دریافت مقادیر تولید شده خودکار (مانند `id`)، باید یک کوئری `SELECT` جداگانه اجرا کنید. PostgreSQL با استفاده از کلمه کلیدی `RETURNING` این مشکل را حل می‌کند.

```postgresql
INSERT INTO
	orders (customer_name, order_date, total_amount)
VALUES
	('yabal', now(), 300.75);

SELECT * FROM orders;
```

<div class="centered-div" style="padding: 1rem 0;">
<img src="../../assets/images/advanced_data_types/select_query_output.png" alt="select query output" />
</div>

شما می‌توانید در انتهای دستور `INSERT` خود، از `RETURNING` برای بازگرداندن مقادیر مورد نظر استفاده کنید. شما حتی می‌توانید با `* RETURNING` کل ردیف درج شده را بازگردانید. این کار از یک سفر رفت و برگشت اضافی به پایگاه داده جلوگیری می‌کند و بسیار کارآمد است.

```postgresql
INSERT INTO
	orders (customer_name, order_date, total_amount)
VALUES
	('mamad', now(), 186)
RETURNING id, order_number;

-- id | order_number
--------------------
--  2 |            2
```
