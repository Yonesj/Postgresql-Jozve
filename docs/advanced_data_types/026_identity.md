### **جلسه 26: ستون‌های شناسه (Identity Columns)**

پس از عبور از مباحث اعداد صحیح، `SERIAL` و دنباله‌ها، بالاخره به ستون‌های شناسه (Identity Columns) می‌رسیم. این روش، راهکار مدرن و ترجیحی برای ایجاد کلیدهای اصلی خودافزا در PostgreSQL است.

---

#### **۱. نحوه ایجاد یک ستون شناسه**

برای ایجاد یک ستون شناسه به عنوان کلید اصلی، باید آن را به صورت زیر تعریف کنیم:

```postgresql
CREATE TABLE id_example (
	id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
	name TEXT
);
```

تجزیه این دستور:

- `id`: نام ستون.
- `BIGINT`: نوع داده که همانطور که قبلاً گفتیم، برای کلیدهای اصلی بهترین انتخاب است.
- `GENERATED ALWAYS AS IDENTITY`: این بخش کلیدی، جایگزین مدرن `SERIAL` است و به PostgreSQL می‌گوید که این ستون همیشه باید به صورت خودکار به عنوان یک شناسه تولید شود.
- `PRIMARY KEY`: ستون را به عنوان کلید اصلی جدول مشخص می‌کند.

با این تعریف، هنگام درج ردیف جدید، نیازی به مشخص کردن مقدار `id` نیست و PostgreSQL به صورت خودکار آن را مقداردهی و افزایش می‌دهد.

```postgresql
insert into id_example (name) values ('yabal') RETURNING id; -- output: 1
```

---

#### **۲. تفاوت `GENERATED ALWAYS` با `GENERATED BY DEFAULT`**

دو حالت برای تعریف یک ستون شناسه وجود دارد که رفتار متفاوتی در برابر درج مقادیر دستی دارند.

- **`GENERATED ALWAYS AS IDENTITY` (حالت پیشنهادی):**
  در این حالت، شما **نمی‌توانید** یک مقدار صریح برای ستون `id` وارد کنید. PostgreSQL با خطا جلوی شما را می‌گیرد. این حالت امنیت و اطمینان بیشتری را فراهم می‌کند، زیرا از درج مقادیر تصادفی یا اشتباهی جلوگیری می‌کند.

  ```postgresql
  insert into id_example (id, name) values (8, 'yabal') RETURNING id;
  -- ERROR:  cannot insert a non-DEFAULT value into column "id"
  -- DETAIL:  Column "id" is an identity column defined as GENERATED ALWAYS.
  -- HINT:  Use OVERRIDING SYSTEM VALUE to override.
  ```

- **`GENERATED BY DEFAULT AS IDENTITY` (حالت انعطاف‌پذیر):**
  در این حالت، اگر شما مقداری برای `id` مشخص نکنید، PostgreSQL مقدار پیش‌فرض (یعنی مقدار بعدی دنباله) را تولید می‌کند. اما اگر شما یک مقدار صریح برای `id` وارد کنید، PostgreSQL آن را **می‌پذیرد**. این حالت انعطاف‌پذیری بیشتری دارد اما خطرناک‌تر است.

  ```postgresql
  CREATE TABLE id_example2 (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT
  );

  insert into id_example2 (name) values ('yabal') RETURNING id; -- 1
  insert into id_example2 (id, name) values (2 ,'yabal') RETURNING id; -- 2
  insert into id_example2 (name) values ('yabal');
  -- ERROR:  duplicate key value violates unique constraint "id_example2_pkey"
  -- DETAIL:  Key (id)=(2) already exists.
  ```

---

#### **۳. درج مقادیر دستی و چالش‌های آن**

اگرچه `GENERATED ALWAYS` جلوی درج مقادیر دستی را می‌گیرد، اما دو راه برای عبور از این محدودیت وجود دارد:

1.  **استفاده از کلمه کلیدی `DEFAULT`:** اگر به هر دلیلی مجبور به مشخص کردن ستون `id` در دستور `INSERT` هستید، می‌توانید به جای یک عدد، از کلمه کلیدی `DEFAULT` استفاده کنید تا PostgreSQL مقدار خودافزا را تولید کند.

    ```postgresql
    insert into id_example (id, name) values (DEFAULT, 'yabal') RETURNING id; -- 2
    ```

2.  **استفاده از `OVERRIDING SYSTEM VALUE`:** این روش به شما اجازه می‌دهد تا به صورت صریح، مقدار تولیدی توسط سیستم را نادیده گرفته و مقدار دلخواه خود را وارد کنید.
    ```postgresql
    insert into id_example (id, name) OVERRIDING SYSTEM VALUE values (3, 'yabal') RETURNING id; -- 3
    ```

**هشدار بسیار مهم:** استفاده از `OVERRIDING SYSTEM VALUE` یک کار **خطرناک** است. وقتی شما یک مقدار را به این صورت وارد می‌کنید، دنباله (sequence) زیربنایی که مسئول تولید شناسه‌هاست، از این موضوع مطلع **نمی‌شود** و شمارنده آن افزایش پیدا نمی‌کند. این باعث می‌شود که جدول و دنباله شما **از همگام‌سازی خارج شوند** و در درج‌های بعدی با خطای کلید تکراری مواجه شوید.

برای حل این مشکل، باید به صورت دستی دنباله را با استفاده از تابع `setval` و `pg_get_serial_sequence` (برای پیدا کردن نام دنباله داخلی) با حداکثر `id` موجود در جدول همگام کنید. این فرآیند پیچیده و مستعد خطا است.

```postgresql
SELECT pg_get_serial_sequence('id_example', 'id'); -- public.id_example_id_seq
SELECT setval(
	'public.id_example_id_seq',
	(SELECT max(id) FROM id_example)
); -- 3
```

---

#### **۴. جمع‌بندی و توصیه نهایی**

- ستون‌های `IDENTITY` روش مدرن و توصیه شده برای ایجاد کلیدهای اصلی خودافزا در PostgreSQL (از نسخه ۱۰ به بعد) هستند.
- همیشه از `BIGINT` برای نوع داده کلید اصلی استفاده کنید.
- استفاده از `GENERATED ALWAYS AS IDENTITY` به دلیل ایجاد یک لایه امنیتی و جلوگیری از خطاهای انسانی، نسبت به `GENERATED BY DEFAULT` ارجحیت دارد.
- از درج مقادیر دستی با `OVERRIDING SYSTEM VALUE` جداً خودداری کنید، مگر اینکه دقیقاً می‌دانید چه کاری انجام می‌دهید و آماده مدیریت عواقب آن (مانند همگام‌سازی دستی دنباله) باشید.

بحث نهایی در مورد اینکه چرا `BIGINT` ممکن است به `UUID` برای کلید اصلی ترجیح داده شود، به جلسه مربوط به ایندکس‌گذاری موکول می‌شود.
