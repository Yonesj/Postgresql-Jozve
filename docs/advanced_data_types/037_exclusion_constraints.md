### **جلسه ۳۷: قید عدم تداخل (Exclusion Constraint)**

در این جلسه، به بررسی قید عدم تداخل (Exclusion Constraint) می‌پردازیم.

---

#### **۱. معرفی قید عدم تداخل و مقایسه آن با `UNIQUE`**

قید عدم تداخل، بسیار شبیه به محدودیت `UNIQUE` است، اما قدرت و انعطاف‌پذیری بسیار بیشتری دارد. اگرچه به اندازه `UNIQUE` از آن استفاده نخواهید کرد، اما در مواقعی که به آن نیاز دارید، یک ابزار فوق‌العاده قدرتمند است.

---

#### **۲. کاربرد اصلی: جلوگیری از همپوشانی بازه‌ها**

یک مثال کلاسیک برای کاربرد قید عدم تداخل، جلوگیری از همپوشانی رزروها در یک سیستم رزرواسیون (مانند رزرو اتاق هتل) است. ما می‌خواهیم تضمین کنیم که دو رزرو برای یک اتاق یکسان، در بازه‌های زمانی همپوشان ثبت نشوند.

برای این کار، از سینتکس `EXCLUDE USING GIST` استفاده می‌کنیم. `GIST` یک نوع ایندکس است که در آینده بیشتر با آن آشنا خواهیم شد. در داخل این دستور، ستون و اپراتور مورد نظر برای بررسی تضاد را مشخص می‌کنیم.

```postgresql
CREATE TABLE reservations (
	id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
	room_id INTEGER,
	reservation_period TSRANGE,

	EXCLUDE USING GIST(reservation_period WITH &&)
);
```

در این مثال، `reservation_period` ستونی از نوع بازه زمانی (`tsrange`) است و `&&` اپراتور بررسی همپوشانی (overlap) است. این محدودیت به PostgreSQL می‌گوید: هنگام درج یا به‌روزرسانی یک ردیف، بررسی کن که آیا بازه زمانی جدید با هر یک از بازه‌های زمانی موجود در جدول (برای همان اتاق) همپوشانی دارد یا خیر. اگر داشت، از درج آن جلوگیری کن.

---

#### **۳. اعمال محدودیت روی چند ستون و نیاز به افزونه `btree_gist`**

محدودیت اولیه ما یک مشکل بزرگ داشت: از همپوشانی رزروها در **تمام اتاق‌ها** جلوگیری می‌کرد. ما باید این محدودیت را به گونه‌ای تغییر دهیم که فقط همپوشانی‌ها را در **همان اتاق** بررسی کند. برای این کار، باید ستون `room_id` را نیز به محدودیت اضافه کنیم.

```postgresql
CREATE TABLE reservations (
	id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
	room_id INTEGER,
	reservation_period TSRANGE,

	EXCLUDE USING GIST(room_id WITH =, reservation_period WITH &&)
);
```

اما هنگام اجرای این دستور، با یک خطا مواجه می‌شویم: ایندکس `GIST` به صورت پیش‌فرض از اپراتور برابری (`=`) برای نوع داده `integer` پشتیبانی نمی‌کند.

**راه حل:** برای حل این مشکل، باید یک افزونه (extension) به نام `btree_gist` را فعال کنیم. این افزونه قابلیت‌های ایندکس `B-Tree` (که در برابری بسیار خوب عمل می‌کند) را به ایندکس `GIST` اضافه می‌کند.

```postgresql
CREATE EXTENSION IF NOT EXISTS btree_gist;
```

پس از فعال‌سازی این افزونه، می‌توانیم محدودیت ترکیبی خود را با موفقیت ایجاد کنیم. اکنون PostgreSQL تضمین می‌کند که برای یک اتاق مشخص، هیچ دو رزروی با بازه زمانی همپوشان وجود نخواهد داشت.

---

#### **۴. قیدهای عدم تداخل جزئی (Partial Exclusion) با شرط `WHERE`**

قدرت قید عدم تداخل به همین جا ختم نمی‌شود. ما می‌توانیم با افزودن یک شرط `WHERE` به انتهای تعریف محدودیت، آن را به یک **محدودیت جزئی (partial)** تبدیل کنیم. این یعنی محدودیت فقط برای ردیف‌هایی که شرط `WHERE` را برآورده می‌کنند، اعمال می‌شود.

برای مثال، در سیستم رزرواسیون، ما می‌خواهیم اجازه دهیم که یک بازه زمانی که قبلاً رزرو شده و سپس **کنسل** شده است، دوباره قابل رزرو باشد. برای این کار، شرط `WHERE` را به این صورت به محدودیت خود اضافه می‌کنیم:

```postgresql
CREATE TABLE reservations (
	id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
	room_id INTEGER,
	booking_status TEXT NOT NULL,
	reservation_period TSRANGE,

	EXCLUDE USING GIST(room_id WITH =, reservation_period WITH &&) WHERE (booking_status != 'canceled')
);
```

با این تعریف، PostgreSQL هنگام بررسی تضاد، رزروهایی که وضعیت آن‌ها `canceled` است را **نادیده می‌گیرد**. این به ما اجازه می‌دهد که برای یک اتاق و یک بازه زمانی یکسان، چندین رزرو کنسل شده داشته باشیم، اما فقط یک رزرو تأیید شده (confirmed). این قابلیت به ما امکان پیاده‌سازی منطق‌های پیچیده کسب‌وکار را مستقیماً در سطح پایگاه داده می‌دهد و از صحت داده‌ها به بهترین شکل محافظت می‌کند.
