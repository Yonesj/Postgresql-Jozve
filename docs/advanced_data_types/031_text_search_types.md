### **جلسه ۳۱: مقدمه‌ای بر جستجوی تمام‌متن (Full-Text Search)**

داشتن قابلیت جستجوی تمام‌متن (Full-Text Search) مستقیماً در داخل پایگاه داده می‌تواند یک مزیت فوق‌العاده باشد، زیرا زیرساخت (stack) شما را ساده نگه می‌دارد و نیازی به استفاده از ابزارهای خارجی مانند Elasticsearch یا Meilisearch نخواهید داشت. راه‌حل داخلی PostgreSQL برای اکثر نیازها (حدود ۸۰ تا ۹۰ درصد) کافی است، هرچند برای موارد بسیار پیشرفته مانند جستجوی چندوجهی (faceted search) یا هایلایت کردن نتایج، ممکن است نیاز به ابزارهای خارجی باشد.

---

#### **۱. دو نوع داده اصلی برای جستجوی تمام‌متن**

برای پیاده‌سازی جستجوی تمام‌متن در PostgreSQL، با دو نوع داده اصلی سروکار داریم. اولین نوع داده `tsvector` است که یک متن ورودی (که به آن سند یا document می‌گویند) را دریافت کرده و آن را به یک فرمت بهینه برای جستجو تبدیل می‌کند. خروجی یک `tsvector`، یک لیست **مرتب‌شده** از **واژگان (lexemes) منحصر به فرد** است. منظور از مرتب‌شده این است که واژگان بر اساس حروف الفبا مرتب می‌شوند. منحصر به فرد به این معناست که هر واژه فقط یک بار در لیست ظاهر می‌شود، اما موقعیت‌های آن در متن اصلی ثبت می‌گردد. واژه یا Lexeme نیز یک واحد پایه‌ای و اتمی زبان است؛ تابع `to_tsvector` کلمات را به ریشه زبانی آن‌ها تبدیل می‌کند. برای مثال، کلمات `lazy` و `laziness` هر دو به یک واژه مشترک (`lazi`) تبدیل می‌شوند که این کار باعث می‌شود جستجوها هوشمندتر عمل کنند.

```postgresql
SELECT to_tsvector('the quick brown fox jumps over the lazy dog, and dog ...');
-- "'brown':3 'dog':9,11 'fox':4 'jump':5 'lazi':8 'quick':2"
```

نوع داده دوم `tsquery` است. این نوع داده، یک رشته جستجو را دریافت کرده و آن را نیز به فرمت واژگان تبدیل می‌کند تا بتوان آن را با یک `tsvector` مقایسه کرد.

---

#### **۲. نحوه انجام جستجوی پایه**

فرآیند اصلی جستجو به این صورت است که شما رشته جستجوی خود را به یک `tsquery` تبدیل کرده و سپس با استفاده از اپراتور `@@`، آن را در مقابل یک ستون از نوع `tsvector` اجرا می‌کنید. برای مثال،

```postgresql
SELECT to_tsvector('the quick brown fox jumps over the lazy dog') @@ to_tsquery('lazy'); -- TRUE
SELECT to_tsvector('the quick brown fox jumps over the lazy dog') @@ to_tsquery('laziness'); -- TRUE
SELECT to_tsvector('the quick brown fox jumps over the lazy dog') @@ to_tsquery('yabal'); -- FALSE
```

بررسی می‌کند که آیا کوئری مورد نظر در داخل وکتور متنی وجود دارد یا خیر. به لطف فرآیند تبدیل به واژگان (lexeming)، جستجوها به صورت خودکار مقداری انعطاف‌پذیری (fuzziness) دارند. برای مثال، جستجوی `laziness` کلمه `lazy` را نیز پیدا خواهد کرد و ترتیب کلمات در کوئری نیز اهمیتی ندارد.

---

#### **۳. همگام‌سازی خودکار `tsvector` با استفاده از ستون‌های تولیدی**

یک چالش رایج این است که ستون متن اصلی (`content`) و ستون وکتور شده آن (`search_vector`) می‌توانند از همگام‌سازی خارج شوند. یک راه‌حل عالی برای این مشکل، استفاده از **ستون‌های تولیدی (Generated Columns)** است. شما می‌توانید ستون `tsvector` را به عنوان یک ستون تولیدی تعریف کنید که مقدار آن همیشه به صورت خودکار از روی ستون متن اصلی محاسبه شود.

```postgresql
CREATE TABLE ts_example (
	id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
	content TEXT,
	search_vector_en TSVECTOR GENERATED ALWAYS AS (to_tsvector('english', content)) STORED
);
```

نکته مهم این است که در ابتدا، ممکن است تابع `to_tsvector(content)` به تنهایی در یک ستون تولیدی کار نکند، زیرا PostgreSQL آن را یک تابع غیرقطعی (non-deterministic) می‌داند. دلیل این است که رفتار این تابع به تنظیمات پیش‌فرض جستجوی متن (`default_text_search_config`) بستگی دارد که ممکن است در آینده تغییر کند. برای حل این مشکل، باید زبان مورد نظر را به صورت صریح به عنوان پارامتر اول به تابع بدهید، مانند `to_tsvector('english', content)`. این کار تابع را **قطعی (deterministic)** و برای استفاده در ستون‌های تولیدی مجاز می‌کند. با این روش، هر زمان که ستون `content` به‌روزرسانی شود، ستون `search_vector` نیز به صورت خودکار و دقیق با آن همگام می‌شود.

```postgresql
INSERT INTO ts_example(content) VALUES ('the quick brown fox jumps over the lazy dog'); -- *
INSERT INTO ts_example(content) VALUES ('so close no matter how far');

SELECT * FROM ts_example WHERE search_vector_en @@ to_tsquery('dog'); -- outputs * record
```

---

#### **۴. جمع‌بندی و نگاهی به آینده**

در این جلسه با دو نوع داده کلیدی `tsvector` و `tsquery` آشنا شدیم و دیدیم که چگونه می‌توان با استفاده از ستون‌های تولیدی، یک سیستم جستجوی تمام‌متن کارآمد و همیشه همگام‌سازی شده ایجاد کرد. اپراتورها و توابع بسیار بیشتری برای جستجوی تمام‌متن وجود دارند (مانند `AND`, `OR`, `NOT`، رتبه‌بندی نتایج، کلمات توقف و...) که در بخش کامل و اختصاصی این دوره به آن‌ها خواهیم پرداخت.
