### **جلسه ۳۵: محدودیت `NOT NULL` و ماهیت `NULL`**

چند جلسه قبل در مورد محدودیت‌های `CHECK` صحبت کردیم. اکنون به سراغ یکی دیگر از انواع مهم محدودیت‌ها یعنی `NOT NULL` می‌رویم.

---

#### **۱. یادآوری ماهیت عجیب `NULL`**

قبل از پرداختن به محدودیت `NOT NULL`، باید به یاد داشته باشیم که مقادیر `NULL` در پایگاه‌های داده رفتاری خاص و عجیب دارند.

- **`NULL` به معنای "نامشخص" است:** یک مقدار `NULL` به معنای صفر، `false` یا یک رشته خالی **نیست**. `NULL` به سادگی به معنای یک مقدار **نامشخص و ناشناخته (unknown)** است.

- **رفتار در مقایسه‌ها:** به دلیل همین ماهیت نامشخص، مقایسه `NULL` با هر مقدار دیگری (حتی با یک `NULL` دیگر) نتیجه `NULL` را برمی‌گرداند. وقتی از پایگاه داده می‌پرسید «آیا عدد ۱ با این چیز مخفی که در دست من است (NULL) برابر است؟»، پایگاه داده پاسخ می‌دهد «نمی‌دانم»، که همان `NULL` است. تنها راه بررسی وجود `NULL`، استفاده از اپراتورهای `IS NULL` یا `IS NOT NULL` است.

در بخش کوئری‌نویسی، بیشتر با منطق سه‌ارزشی بولین (three-valued Boolean logic) که ناشی از وجود `NULL` است، آشنا خواهیم شد.

---

#### **۲. توصیه مهم: ستون‌ها را به صورت پیش‌فرض `NOT NULL` تعریف کنید**

یک توصیه بسیار مهم این است که **تا حد امکان، ستون‌های خود را به صورت `NOT NULL` تعریف کنید**. اگر مدل داده شما اجازه می‌دهد، این کار را انجام دهید.

اعمال این محدودیت مزایای زیادی دارد. مهم‌ترین مزیت، تضمین این است که یک مقدار همیشه در آن ستون وجود خواهد داشت. علاوه بر این، در فرآیندهایی مانند ایندکس‌گذاری، مقایسه، گروه‌بندی، مرتب‌سازی و به طور کلی کوئری‌نویسی، کار با ستون‌های `NOT NULL` بسیار ساده‌تر و بهینه‌تر است.

**قانون کلی:** پیش‌فرض شما باید تعریف ستون‌ها به صورت `NOT NULL` باشد، مگر اینکه دلیل خوبی برای `nullable` بودن آن‌ها داشته باشید.

---

#### **۳. نحوه اعمال محدودیت `NOT NULL`**

برای اعمال این محدودیت، به سادگی کلمه کلیدی `NOT NULL` را پس از تعریف نوع داده یک ستون قرار دهید.

```postgresql
CREATE TABLE products (
	id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
	name TEXT NOT NULL,
	price NUMERIC NOT NULL CHECK(price > 0)
);
```

**نکته در مورد کلید اصلی:** وقتی یک ستون را به عنوان `PRIMARY KEY` تعریف می‌کنید، PostgreSQL به صورت خودکار محدودیت `NOT NULL` را نیز روی آن اعمال می‌کند، زیرا یک کلید اصلی هرگز نمی‌تواند `NULL` باشد.

**روش‌های جایگزین (که توصیه نمی‌شوند):**
اگرچه شما می‌توانید با استفاده از یک `CHECK` constraint (مانند `CHECK (name IS NOT NULL)`) همین کار را انجام دهید، اما این روش **توصیه نمی‌شود**، زیرا استفاده از کلمه کلیدی `NOT NULL` بهینه‌تر و خواناتر است.

---

#### **۴. ترکیب `NOT NULL` با دیگر محدودیت‌ها**

شما می‌توانید محدودیت `NOT NULL` را با دیگر محدودیت‌ها، مانند `CHECK`، ترکیب کنید. برای مثال، می‌توانید برای ستون `price` هم تضمین کنید که `NULL` نباشد و هم اینکه مقدار آن همیشه بزرگتر از صفر باشد:
`price NUMERIC NOT NULL CHECK (price > 0)`

با این کار، هم از ورود مقادیر نامشخص و هم از ورود مقادیر صفر (که ممکن است در منطق کسب‌وکار شما معادل `NULL` باشد) جلوگیری می‌کنید.
