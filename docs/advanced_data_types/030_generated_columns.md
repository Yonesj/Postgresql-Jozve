### **جلسه ۳۰: ستون‌های تولیدی (Generated Columns)**

ستون‌های تولیدی (Generated Columns) یکی از ویژگی‌های مورد علاقه مدرس در هر پایگاه داده‌ای، از جمله PostgreSQL، هستند. این ستون‌ها مانند یک راه فرار عمل می‌کنند و می‌توانند به ما در تمیز کردن کوئری‌های نامرتب یا اصلاح مدل‌های داده‌ای که به مرور زمان دچار مشکل شده‌اند، کمک کنند.

---

#### **۱. ستون تولیدی چیست؟**

یک ستون تولیدی در واقع یک ستون معمولی است، اما مقدار آن به صورت مستقیم وارد نمی‌شود، بلکه بر اساس یک **فرمول یا تبدیل** روی یک یا چند ستون دیگر در همان ردیف محاسبه می‌شود. می‌توان آن را شبیه به یک ستون فرمول‌نویسی شده در اکسل یا گوگل شیتس در نظر گرفت.

در حالت کلی، ستون‌های تولیدی دو نوع دارند: مجازی (Virtual) و ذخیره شده (Stored). نوع مجازی در زمان کوئری گرفتن محاسبه می‌شود، اما PostgreSQL فقط از نوع **ذخیره شده (Stored)** پشتیبانی می‌کند. این به این معناست که مقدار ستون تولیدی در زمان `INSERT` یا `UPDATE` محاسبه شده و به صورت فیزیکی روی دیسک ذخیره می‌شود.

---

#### **۲. نحوه ایجاد و استفاده از ستون‌های تولیدی**

برای ایجاد یک ستون تولیدی، از سینتکس `GENERATED ALWAYS AS (expression) STORED` استفاده می‌کنیم. کلمه کلیدی `STORED` در PostgreSQL الزامی است.

**مثال اول: همگام‌سازی واحدها**
تصور کنید جدولی برای ذخیره قد افراد دارید و می‌خواهید آن را هم به سانتی‌متر و هم به اینچ داشته باشید. به جای اینکه سعی کنید این دو ستون را به صورت دستی با هم هماهنگ نگه دارید، می‌توانید یکی را به عنوان ستون تولیدی تعریف کنید:

```postgresql
CREATE TABLE person (
	height_cm NUMERIC,
	height_in NUMERIC GENERATED ALWAYS AS (height_cm / 2.54) STORED
);
```

با این کار، هرگاه مقداری را برای `height_cm` وارد کنید، مقدار `height_in` به صورت خودکار محاسبه و ذخیره می‌شود. نکته مهم این است که شما **نمی‌توانید** به صورت مستقیم در یک ستون تولیدی مقداری را وارد کنید که این خود یک مزیت است و از بروز ناهماهنگی در داده‌ها جلوگیری می‌کند.

```postgresql
INSERT INTO person (height_cm) VALUES (170) RETURNING (height_in); -- 66.9291338582677165

INSERT INTO person (height_cm, height_in) VALUES (170, 66.92);
-- ERROR:  cannot insert a non-DEFAULT value into column "height_in"
-- DETAIL:  Column "height_in" is a generated column.
```

**مثال دوم: استخراج بخشی از یک داده**
یک کاربرد بسیار مفید دیگر، استخراج یک بخش از یک داده پیچیده‌تر است. برای مثال، می‌توانید دامنه (domain) را از یک آدرس ایمیل استخراج کرده و در یک ستون جداگانه ذخیره کنید:
`email TEXT,`
`email_domain TEXT GENERATED ALWAYS AS (split_part(email, '@', 2)) STORED`

با این کار، شما یک ستون جدید به نام `email_domain` دارید که می‌توانید به راحتی روی آن فیلتر، گروه‌بندی یا حتی ایندکس ایجاد کنید، بدون اینکه نیاز به پردازش‌های متنی پیچیده در هر کوئری داشته باشید.

---

#### **۳. محدودیت‌های ستون‌های تولیدی**

استفاده از ستون‌های تولیدی با چند محدودیت مهم همراه است:

- **ارجاع فقط به ردیف فعلی:** فرمول یک ستون تولیدی فقط می‌تواند به ستون‌های دیگر در **همان ردیف** ارجاع دهد و نمی‌تواند به ردیف‌های دیگر، جداول دیگر یا زیرکوئری‌ها (subqueries) دسترسی داشته باشد.
- **استفاده از توابع قطعی (Deterministic):** تابعی که برای محاسبه مقدار ستون استفاده می‌شود، باید قطعی باشد. این یعنی به ازای یک ورودی مشخص، باید همیشه یک خروجی یکسان تولید کند. بنابراین، شما نمی‌توانید از توابع غیرقطعی (volatile) مانند `random()`، `current_time` یا `gen_random_uuid()` در تعریف یک ستون تولیدی استفاده کنید.
- **عدم ارجاع به ستون تولیدی دیگر:** شما نمی‌توانید یک ستون تولیدی را بر اساس یک ستون تولیدی دیگر تعریف کنید. این زنجیره‌سازی فرمول‌ها که در اکسل ممکن است، در اینجا مجاز نیست.

---

#### **۴. جمع‌بندی و کاربردهای آینده**

ستون‌های تولیدی ابزاری فوق‌العاده قدرتمند هستند، هم برای اصلاح مدل‌های داده نامرتب و هم برای کار با داده‌های نامرتبی که کنترل کاملی بر آن‌ها نداریم. این ستون‌ها می‌توانند برای استخراج بخش‌هایی از یک سند JSON نیز بسیار مفید باشند که در آینده به آن خواهیم پرداخت. در طول این دوره، بارها از این قابلیت استفاده خواهیم کرد، زیرا یک ابزار بسیار کارآمد برای حل بسیاری از مشکلات واقعی است.
