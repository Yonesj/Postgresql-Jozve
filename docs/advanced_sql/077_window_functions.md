### **جلسه ۷۷: توابع پنجره‌ای (Window Functions)**

توابع پنجره‌ای یک روش بسیار قدرتمند برای انجام محاسبات روی یک **"پنجره" یا بخشی از ردیف‌ها** در یک مجموعه نتیجه هستند، بدون اینکه ردیف‌های اصلی را در هم ادغام کنند.

---

#### **۱. تفاوت کلیدی با `GROUP BY`**

برخلاف `GROUP BY` که ردیف‌ها را در گروه‌هایی خلاصه کرده و جزئیات ردیف‌های فردی را از بین می‌برد، یک تابع پنجره‌ای **تمام ردیف‌های اصلی را حفظ می‌کند**. این تابع صرفاً یک یا چند ستون محاسباتی جدید به هر ردیف اضافه می‌کند که بر اساس "پنجره" تعریف شده برای آن ردیف محاسبه شده است.

---

#### **۲. ساختار یک تابع پنجره‌ای**

یک تابع پنجره‌ای با استفاده از کلمه کلیدی `OVER` تعریف می‌شود. در داخل پرانتز `OVER`، شما می‌توانید سه بخش اصلی را برای تعریف "پنجره" خود مشخص کنید:

1.  **`PARTITION BY` (اختیاری):** این عبارت مجموعه نتایج را به بخش‌های مجزا یا "پارتیشن" تقسیم می‌کند. تابع پنجره‌ای به صورت مستقل روی هر پارتیشن اعمال می‌شود. اگر این بخش را مشخص نکنید، کل مجموعه نتایج به عنوان یک پارتیشن واحد در نظر گرفته می‌شود.

2.  **`ORDER BY` (اختیاری):** این عبارت ترتیب ردیف‌ها را **در داخل هر پارتیشن** مشخص می‌کند. این ترتیب برای توابعی که به موقعیت ردیف حساس هستند (مانند `first_value`, `last_value`, `row_number`) حیاتی است.

3.  **`Frame Clause` (اختیاری):** این عبارت (که با کلماتی مانند `ROWS` یا `RANGE` شروع می‌شود) به طور دقیق مشخص می‌کند که پنجره برای هر ردیف، شامل چه تعداد ردیف قبل و بعد از آن ردیف فعلی است.

---

#### **۳. مثال‌های عملی**

*   **محاسبه میانگین در هر پارتیشن:**
    برای محاسبه میانگین فروش به تفکیک هر منطقه (`region`)، بدون از دست دادن جزئیات هر فروش، می‌توانیم به این صورت عمل کنیم:
    ```postgresql
    SELECT 
	    *, AVG(amount) OVER (PARTITION BY region) AS avg_region 
    FROM sales;
    ```
    در این مثال، برای تمام ردیف‌های مربوط به یک منطقه خاص، مقدار `avg_per_region` یکسان خواهد بود.

    ??? note "خروجی کوئری بالا"
        <div class='centered-div'>
          <img src="../../assets/images/advanced_sql/77_1.png">
        </div>

*   **پیدا کردن اولین و آخرین مقدار در هر پارتیشن:**
    توابعی مانند `first_value` و `last_value` به ترتیب اولین و آخرین مقدار یک ستون را در پنجره فعلی برمی‌گردانند. برای یافتن اولین بوکمارک هر کاربر به این گونه عمل می کنیم:
    ```postgresql
    SELECT
      *,
      FIRST_VALUE(id) OVER (
        PARTITION BY user_id
        ORDER BY id ASC
      ) AS first_bookmark
    FROM bookmarks;
    ```

    ??? note "خروجی کوئری بالا"
        <div class='centered-div'>
          <img src="../../assets/images/advanced_sql/77_2.png">
        </div>
---

#### **۴. درک Frame پیش‌فرض و چالش `last_value`**

به صورت پیش‌فرض، Frame یک پنجره از **ابتدای پارتیشن تا ردیف فعلی** (`ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`) تعریف می‌شود. این رفتار باعث می‌شود که تابع `first_value` همیشه به درستی کار کند، اما تابع `last_value` نتیجه‌ای غیرمنتظره تولید کند (مقدار آن در هر ردیف برابر با مقدار همان ردیف خواهد بود).

**راه حل:** برای اینکه `last_value` کل پارتیشن را ببیند، باید Frame را به صورت صریح تعریف کنیم تا شامل تمام ردیف‌های بعد از ردیف فعلی نیز بشود:

```postgresql
... OVER (... ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
```

---

#### **۵. تعریف پنجره‌های نام‌گذاری شده با `WINDOW`**

اگر از یک تعریف پنجره یکسان در چندین تابع استفاده می‌کنید، برای جلوگیری از تکرار و افزایش خوانایی، می‌توانید با استفاده از عبارت `WINDOW` در انتهای کوئری، یک نام برای آن تعریف پنجره مشخص کرده و سپس در توابع خود از آن نام استفاده کنید.

```postgresql
SELECT
	*,
	ROW_NUMBER() OVER user_bookmarks,
	FIRST_VALUE(id) OVER user_bookmarks,
	LAST_VALUE(id) OVER user_bookmarks
FROM bookmarks
WINDOW user_bookmarks AS (
	PARTITION BY user_id
	ORDER BY id ASC
	ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
);
```

??? note "خروجی کوئری بالا"
    <div class='centered-div'>
      <img src="../../assets/images/advanced_sql/77_3.png">
    </div>

این کار نه تنها خوانایی را بهبود می‌بخشد، بلکه به PostgreSQL نیز کمک می‌کند تا بفهمد که این محاسبات باید فقط یک بار انجام شوند که به بهینه‌سازی عملکرد کمک می‌کند.

---

#### **۶. استفاده از `RANGE` در تعریف Frame**

علاوه بر `ROWS` (که بر اساس تعداد ردیف‌ها عمل می‌کند)، می‌توانید از `RANGE` نیز برای تعریف Frame استفاده کنید. `RANGE` بر اساس **مقدار ستون مرتب‌سازی** عمل می‌کند.
**مثال:** پیدا کردن بیشترین فروش در یک بازه ۱۰ روزه (۵ روز قبل و ۵ روز بعد از هر فروش):

```postgresql
SELECT
	*,
	MAX(amount) OVER (
		ORDER BY sale_date asc
		RANGE BETWEEN '5 days' PRECEDING AND '5 days' FOLLOWING
	)
FROM
	sales;
```

??? note "خروجی کوئری بالا"
    <div class='centered-div'>
      <img src="../../assets/images/advanced_sql/77_4.png">
    </div>

---

#### **۷. دیگر توابع پنجره‌ای مهم**

علاوه بر توابع تجمعی معمولی، توابع بسیار قدرتمند دیگری نیز وجود دارند که فقط به عنوان توابع پنجره‌ای قابل استفاده هستند:

- `()ROW_NUMBER`: شماره ردیف را در هر پارتیشن برمی‌گرداند.
- `RANK()` / `DENSE_RANK`: رتبه هر ردیف را مشخص می‌کنند.
- `LEAD()` / `LAG`: به شما اجازه می‌دهند تا به مقدار یک ستون در ردیف‌های بعدی یا قبلی دسترسی داشته باشید.

و بسیاری توابع آماری دیگر...

---

#### **۸. جمع‌بندی**

توابع پنجره‌ای به شما اجازه می‌دهند تا محاسبات پیچیده‌ای را روی زیرمجموعه‌ای از ردیف‌ها انجام دهید، در حالی که تمام جزئیات ردیف‌های اصلی را حفظ می‌کنید. این ابزار قدرتمند، امکان تحلیل‌های عمیق داده، مانند محاسبه میانگین‌های متحرک، رتبه‌بندی و مقایسه ردیف‌ها با یکدیگر را مستقیماً در داخل پایگاه داده فراهم می‌کند.