در این جلسه با نماها (`Views`) آشنا می‌شویم. نماها از نظر مفهومی شبیه به `CTE`ها هستند، زیرا به شما اجازه می‌دهند تا یک کوئری پیچیده را در قالب یک واحد سازمان‌یافته و نام‌گذاری شده بسته‌بندی کنید.

---

#### **۱. تفاوت کلیدی `View` با `CTE`**

تفاوت اصلی بین `View` و `CTE` در **ماندگاری (persistence)** آن‌هاست.
یک `CTE` موقتی است و فقط در محدوده همان کوئری که در آن تعریف شده، قابل استفاده است.
اما یک `View` یک شیء دائمی در پایگاه داده است. شما یک `View` را یک بار ایجاد می‌کنید و سپس می‌توانید بارها و بارها، در کوئری‌های مختلف، به آن مانند یک جدول معمولی ارجاع دهید.

---

#### **۲. نحوه ایجاد یک `View`**

ایجاد یک `View` بسیار ساده است. تنها کافیست به جای `WITH` که برای `CTE` استفاده می‌کردیم، از `CREATE VIEW` استفاده کنیم. بیایید همان منطق `UNION` بین جداول `users` و `users_archive` را که قبلاً با `CTE` پیاده‌سازی کردیم، به یک `View` تبدیل کنیم:

```postgresql
CREATE VIEW all_users AS (
	SELECT * FROM users
	UNION ALL
	SELECT * FROM users_archive
);
```

پس از ایجاد این `View`، ما می‌توانیم به سادگی کوئری‌های خود را روی `all_users` اجرا کنیم، انگار که یک جدول واقعی است.

```postgresql
SELECT * FROM all_users WHERE email = '...';
```

---

#### **۳. مهم‌ترین نکته در مورد عملکرد `View`**

یک `View` معمولی، داده‌ها را به صورت فیزیکی ذخیره یا کپی **نمی‌کند**. یک `View` در واقع چیزی جز یک **کوئری ذخیره شده** نیست که یک نام به آن اختصاص داده شده است. این یعنی هر بار که شما از یک `View` کوئری می‌گیرید، PostgreSQL در پس‌زمینه، کوئری اصلی و زیربنایی آن `View` را **دوباره اجرا می‌کند**.

*   **مزیت:** داده‌هایی که از `View` می‌خوانید، همیشه **به‌روز** هستند.
*   **عیب:** شما از یک `View` معمولی هیچ **مزیت عملکردی (performance benefit)** به دست نمی‌آورید. اگر کوئری زیربنایی `View` کند و پرهزینه باشد، هر بار کوئری گرفتن از آن `View` نیز به همان اندازه کند خواهد بود.

---

#### **۴. کاربردهای عملی `View`**

*   **ساده‌سازی کوئری‌های پیچیده:** شما می‌توانید یک `JOIN` پیچیده یا یک منطق تجاری تکراری را در یک `View` کپسوله کرده و سپس در کوئری‌های خود از آن `View` ساده شده استفاده کنید.
*   **ایجاد یک لایه انتزاعی (Abstraction Layer):** `View`ها می‌توانند به عنوان یک لایه میانی بین اپلیکیشن و ساختار واقعی جداول عمل کنند. این ویژگی به خصوص در زمان مهاجرت (migration) یا بازسازی اسکیما بسیار مفید است. شما می‌توانید یک `View` ایجاد کنید که ساختار قدیمی را شبیه‌سازی می‌کند، در حالی که در پس‌زمینه در حال تغییر ساختار واقعی جداول هستید.

---

#### **۵. ترفند پیشرفته: بازنویسی یک جدول با `View`**

یک تکنیک پیشرفته این است که با استفاده از اسکیمای (`schema`) مجزا و تنظیم `search_path`، یک `View` را جایگزین یک جدول واقعی کنید. `search_path` مسیرهایی را مشخص می کند که Postgres به دنبال جداول می گردد.

```postgresql
SHOW search_path; -- public
```

1.  یک اسکیمای جدید (مثلاً `views`) ایجاد کنید.
  ```postgresql
  CREATE SCHEMA views;
  ```
2.  `search_path` نشست خود را طوری تنظیم کنید که ابتدا در اسکیمای `views` و سپس در اسکیمای `public` جستجو کند.
  ```postgresql
  SET search_path = views, public;
  ```
3.  یک `View` در اسکیمای `views` با نامی **دقیقاً مشابه** نام جدول اصلی خود (مثلاً `views.users`) ایجاد کنید.
  ```postgresql
  CREATE VIEW views.users AS (...);
  ```

با این کار، هر کوئری بدون پیشوندی که به جدول `users` ارجاع دهد، به جای جدول واقعی در اسکیمای `public`، ابتدا `View` شما را در اسکیمای `views` پیدا و اجرا خواهد کرد. این یک روش قدرتمند برای "پنهان کردن" یا "بازنویسی" رفتار یک جدول بدون تغییر کد اپلیکیشن است.

---

#### **۶. جمع‌بندی**

`View`های معمولی ابزاری عالی برای سازماندهی، ساده‌سازی و ایجاد یک لایه انتزاعی روی کوئری‌های پیچیده هستند. اما به یاد داشته باشید که آن‌ها هیچ بهبود عملکردی در زمان خواندن ایجاد نمی‌کنند. برای دستیابی به این بهبود عملکرد، باید به سراغ **Materialized Views** برویم که در جلسه بعد به آن خواهیم پرداخت.