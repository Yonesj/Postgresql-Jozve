در این جلسه، به پشت صحنه پلتفرمی که در حال تماشای این دوره روی آن هستید، نگاهی می‌اندازیم و می‌بینیم که چگونه با ترکیب `COALESCE` و ستون‌های تولیدی (`generated columns`)، یک مسئله واقعی به شکلی هوشمندانه حل شده است.

---

### **۱. سناریو: مدیریت ویدیوهای حالت روشن و تاریک**

در این پلتفرم، ویدیوها در دو نسخه حالت روشن (`light mode`) و حالت تاریک (`dark mode`) وجود دارند. این ویدیوها در جدولی به نام `videos` مدیریت می‌شوند که دو ستون کلید خارجی به نام‌های `cloudflare_light_id` و `cloudflare_dark_id` دارد.

```postgresql
CREATE TABLE cloudflare_videos (
	id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
	path TEXT
);

CREATE TABLE videos (
	id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
	title TEXT,
	cloudflare_light_id BIGINT REFERENCES cloudflare_videos(id),
	cloudflare_dark_id BIGINT REFERENCES cloudflare_videos(id)
);
```

**چالش:**
برخی از ویدیوها (مانند مصاحبه‌ها) نسخه حالت تاریک ندارند و ستون `cloudflare_dark_id` برای آن‌ها `NULL` است. ما نمی‌خواهیم در سمت اپلیکیشن، در نقاط مختلف، کدهای شرطی بنویسیم تا بررسی کنیم که آیا نسخه تاریک وجود دارد یا نه و اگر وجود نداشت، نسخه روشن را نمایش دهیم. ما می‌خواهیم این منطق را یک بار و برای همیشه در سطح پایگاه داده حل کنیم.

---

### **۲. راه‌حل: ایجاد یک ستون تولیدی "امن"**

راه‌حل این مشکل، ایجاد یک ستون تولیدی جدید است که این منطق جایگزینی را در خود کپسوله کند. ما یک ستون جدید به نام `cloudflare_safe_dark_id` به جدول `videos` اضافه می‌کنیم.

این ستون به عنوان یک **ستون تولیدی ذخیره شده (generated stored column)** و با استفاده از تابع `COALESCE` تعریف می‌شود:

```postgresql
ALTER TABLE videos 
  ADD COLUMN cloudflare_safe_dark_id BIGINT GENERATED ALWAYS AS (
    COALESCE(cloudflare_dark_id, cloudflare_light_id)
  ) STORED;
```

---

### **۳. نحوه کارکرد این راه‌حل**

این ستون تولیدی به صورت زیر عمل می‌کند:

*   تابع `COALESCE` دو آرگومان `cloudflare_dark_id` و `cloudflare_light_id` را دریافت می‌کند.
*   اگر `cloudflare_dark_id` مقدار داشته باشد (یعنی `NOT NULL` باشد)، تابع همان مقدار را برمی‌گرداند.
*   اگر `cloudflare_dark_id` برابر `NULL` باشد، تابع به سراغ آرگومان بعدی رفته و مقدار `cloudflare_light_id` را برمی‌گرداند.

نتیجه این است که ستون `cloudflare_safe_dark_id` **همیشه** یک مقدار معتبر خواهد داشت. این مقدار یا شناسه ویدیوی حالت تاریک است، یا اگر وجود نداشته باشد، شناسه ویدیوی حالت روشن خواهد بود.

---

### **۴. مزیت نهایی برای اپلیکیشن**

با این راه‌حل، در سمت اپلیکیشن، ما دیگر هرگز با ستون‌های `_light_id` و `_dark_id` به صورت مستقیم کار نمی‌کنیم. ما همیشه به ستون `cloudflare_safe_dark_id` ارجاع می‌دهیم. این کار به ما این **تضمین** را می‌دهد که همیشه یک "نسخه تاریک" از ویدیو در دسترس است، حتی اگر آن نسخه در واقع کپی‌ای از نسخه روشن باشد.

این یک مثال عالی از این است که چگونه مفاهیمی که در طول دوره یاد گرفته‌ایم (مانند توابع کار با `NULL` و ستون‌های تولیدی) می‌توانند با هم ترکیب شوند تا راه‌حل‌های بسیار زیبا، کارآمد و قابل نگهداری برای مسائل دنیای واقعی ایجاد کنند. این کار پیچیدگی را از لایه اپلیکیشن حذف کرده و آن را به جایی که به آن تعلق دارد، یعنی پایگاه داده، منتقل می‌کند.