
### **جلسه ۸۰: CTEهای بازگشتی (Recursive CTEs)**

پس از آشنایی با CTEهای معمولی، اکنون به سراغ **CTEهای بازگشتی (Recursive CTEs)** می‌رویم که به طرز شگفت‌انگیزی قدرتمندتر هستند. یک CTE بازگشتی به ما اجازه می‌دهد تا یک کوئری را به صورت مکرر اجرا کرده و حتی به نتیجه خود ارجاع دهد تا یک مجموعه نتیجه را به صورت تدریجی بسازد.

---

#### **۱. ساختار یک CTE بازگشتی**

یک CTE بازگشتی با کلمه کلیدی `WITH RECURSIVE` شروع می‌شود و ساختار داخلی آن از دو بخش اصلی تشکیل شده است که با `UNION` یا `UNION ALL` از هم جدا می‌شوند.

1.  **بخش پایه یا لنگر (Anchor Member):** این بخش، بخش **غیر بازگشتی** است و نقطه شروع فرآیند را مشخص می‌کند. این کوئری فقط **یک بار** در ابتدا اجرا می‌شود و مجموعه نتایج اولیه را تولید می‌کند.

2.  **بخش بازگشتی (Recursive Member):** این بخش به صورت مکرر اجرا می‌شود. در هر تکرار، این بخش می‌تواند به نتایج تولید شده در تکرار **قبلی** (با ارجاع به نام خود CTE) دسترسی داشته باشد و ردیف‌های جدیدی را تولید کند. این فرآیند تا زمانی که بخش بازگشتی دیگر هیچ ردیف جدیدی تولید نکند، ادامه می‌یابد.

---

#### **۲. مثال اول: تولید یک سری اعداد ساده**

اگرچه برای تولید سری‌های عددی ساده با گام ثابت، `generate_series` ابزار بهتری است، اما می‌توان این کار را با یک CTE بازگشتی نیز انجام داد تا با ساختار آن آشنا شویم.

```postgresql
WITH RECURSIVE numbers AS (
	SELECT 1 AS n
	UNION ALL
	SELECT n + 1 FROM numbers WHERE n < 10
)
SELECT * FROM numbers;
```

در این مثال، بخش پایه مقدار `1` را تولید می‌کند. سپس بخش بازگشتی در هر مرحله، مقدار قبلی (`n`) را گرفته، آن را به علاوه یک کرده و تا زمانی که شرط `n < 10` برقرار باشد، این کار را تکرار می‌کند.

---

#### **۳. اهمیت شرط توقف (Termination Condition)**

یک نکته حیاتی در کار با CTEهای بازگشتی، داشتن یک **شرط توقف** است. اگر شرط توقفی وجود نداشته باشد، کوئری وارد یک **حلقه بی‌نهایت (infinite loop)** خواهد شد. شرط توقف می‌تواند به دو صورت باشد:

1.  یک شرط `WHERE` صریح (مانند `WHERE n < 10`).
2.  به پایان رسیدن طبیعی داده‌ها، به طوری که بخش بازگشتی دیگر ردیف جدیدی تولید نکند (مانند زمانی که در یک `JOIN`، دیگر مطابقی پیدا نمی‌شود).

---

#### **۴. مثال دوم: تولید یک سری با گام‌های تصادفی**

CTEهای بازگشتی می‌توانند کارهایی را انجام دهند که `generate_series` قادر به انجام آن نیست. برای مثال، می‌توانیم یک سری اعداد صعودی با گام‌های تصادفی ایجاد کنیم.

```postgresql
WITH RECURSIVE random_series AS (
	SELECT 1 AS num
	UNION ALL
	SELECT num + floor(random() * 10 + 1)::int FROM random_series WHERE num < 100
)
SELECT * FROM random_series;
```

---

#### **۵. مثال سوم: محاسبه دنباله فیبوناچی**

CTEهای بازگشتی برای محاسبه دنباله‌هایی که هر جمله به جملات قبلی خود وابسته است، مانند دنباله فیبوناچی، ابزاری ایده‌آل هستند.

```postgresql
WITH RECURSIVE fibonacci(id, a, b) AS (
	VALUES (1, 0, 1)
	UNION ALL
	SELECT id + 1, b, a + b FROM fibonacci WHERE id < 20
)
SELECT id, a AS fib_number FROM fibonacci;
```

در این مثال، برای خوانایی بیشتر، نام ستون‌ها در تعریف اولیه `CTE` مشخص شده است. بخش بازگشتی با استفاده از مقادیر `a` و `b` از ردیف قبلی، جمله بعدی دنباله را محاسبه می‌کند.

---

#### **۶. جمع‌بندی**

یک CTE بازگشتی از یک بخش پایه (برای شروع) و یک بخش بازگشتی (برای تکرار) تشکیل شده است. این ابزار قدرتمند به شما اجازه می‌دهد تا مجموعه‌های داده را به صورت تدریجی و بر اساس نتایج مراحل قبلی بسازید. همیشه مطمئن شوید که یک شرط توقف مشخص برای جلوگیری از حلقه‌های بی‌نهایت در کوئری خود دارید. در جلسه بعد، به یکی از کاربردی‌ترین موارد استفاده از CTEهای بازگشتی، یعنی کار با داده‌های سلسله‌مراتبی، خواهیم پرداخت.