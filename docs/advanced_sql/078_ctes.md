### **جلسه ۷۸: عبارت‌های جدولی مشترک (CTEs)**

عبارت‌های جدولی مشترک، که به اختصار `CTE` (Common Table Expression) نامیده می‌شوند، راهی برای **بازسازی و سازماندهی (refactor)** کوئری‌های شما هستند. یک `CTE` به شما اجازه می‌دهد تا بخش‌های پیچیده یک کوئری را به واحدهای منطقی و نام‌گذاری شده تقسیم کنید که این کار خوانایی و قابلیت نگهداری کوئری را به شدت افزایش می‌دهد.

---

#### **۱. ساختار یک CTE ساده**

یک `CTE` با کلمه کلیدی `WITH` شروع می‌شود. شما یک نام برای `CTE` خود انتخاب کرده، سپس در داخل پرانتز، کوئری مربوط به آن را می‌نویسید. در نهایت، در کوئری اصلی خود، می‌توانید به این `CTE` مانند یک جدول واقعی ارجاع دهید.

```postgresql
WITH my_cte AS (
	SELECT ... FROM ...
)
SELECT * FROM my_cte;
```

---

#### **۲. کاربرد عملی: ترکیب جداول با `UNION` در یک CTE**

به یاد بیاورید که در جلسات قبل، برای جستجو در دو جدول `users` و `users_archive` از `UNION` استفاده کردیم. ما می‌توانیم این منطق `UNION` را در داخل یک `CTE` به نام `all_users` کپسوله کنیم.

```postgresql
WITH all_users AS (
	SELECT *, false AS is_deleted FROM users
	UNION ALL
	SELECT *, true AS is_deleted FROM users_archive
)
SELECT * FROM all_users WHERE email = '...';
```

با این کار، کوئری اصلی ما بسیار ساده و خوانا می‌شود و تمام پیچیدگی مربوط به ترکیب جداول در داخل `CTE` پنهان می‌شود.

!!! tip "یک ترفند جالب (و بحث‌برانگیز)"
    شما حتی می‌توانید نام `CTE` خود را `users` بگذارید. با این کار، در ادامه کوئری، هر ارجاعی به `users` به نتیجه `CTE` شما اشاره خواهد کرد، نه جدول اصلی. این تکنیک می‌تواند در کار با `ORM`ها برای گسترش قابلیت‌های آن‌ها بدون تغییر کد اپلیکیشن، مفید باشد.

---

#### **۳. عملکرد CTE و مفهوم Materialization**

یک سوال مهم در مورد عملکرد `CTE`ها این است که PostgreSQL چگونه آن‌ها را اجرا می‌کند. PostgreSQL می‌تواند تصمیم بگیرد که یک `CTE` را **مادی‌سازی (materialize)** بکند یا نکند.

*   **مادی‌سازی (Materialization):** در این حالت، PostgreSQL ابتدا کوئری داخل `CTE` را به طور کامل اجرا کرده و نتیجه آن را در یک **جدول موقت داخلی** ذخیره می‌کند. سپس، در ادامه کوئری، از این جدول موقت استفاده می‌کند.
*   **عدم مادی‌سازی (Inlining):** در این حالت، PostgreSQL کوئری `CTE` را به عنوان بخشی از کوئری اصلی در نظر گرفته و آن را "درون‌خطی" (inline) می‌کند. این یعنی منطق `CTE` به داخل کوئری اصلی "فشار داده می‌شود" (pushed down).

!!! note "قانون کلی PostgreSQL"
    اگر یک `CTE` فقط **یک بار** در کوئری اصلی استفاده شود، به صورت پیش‌فرض مادی‌سازی **نمی‌شود**.
    در غیر این صورت **مادی‌سازی شده** تا از اجرای چندباره یک کوئری یکسان جلوگیری شود.

---

#### **۴. کنترل دستی فرآیند Materialization**

گاهی اوقات، شما ممکن است با تصمیم PostgreSQL موافق نباشید. برای این موارد، می‌توانید با استفاده از کلمات کلیدی `MATERIALIZED` و `NOT MATERIALIZED`، رفتار پیش‌فرض را تغییر دهید.

*   `...WITH my_cte AS MATERIALIZED`: این دستور PostgreSQL را **مجبور** به مادی‌سازی `CTE` می‌کند.
*   `...WITH my_cte AS NOT MATERIALIZED`: این دستور PostgreSQL را از مادی‌سازی `CTE` **منع می‌کند**.

استفاده نادرست از این کلمات کلیدی می‌تواند به شدت به عملکرد آسیب بزند. برای مثال، مادی‌سازی اجباری یک `CTE` بزرگ که فقط یک بار استفاده می‌شود، می‌تواند بسیار پرهزینه‌تر از حالت پیش‌فرض باشد. از این گزینه‌ها فقط زمانی استفاده کنید که دقیقاً می‌دانید چرا تصمیم PostgreSQL بهینه نیست.

---

#### **۵. زنجیره‌سازی CTEها**

شما می‌توانید چندین `CTE` را در یک کوئری واحد تعریف کرده و آن‌ها را به صورت زنجیروار به هم متصل کنید. یک `CTE` می‌تواند به `CTE`هایی که قبل از آن تعریف شده‌اند، ارجاع دهد.

```postgresql
WITH 
	all_users AS (...),
	aarons AS (
		SELECT * FROM all_users WHERE ...
	)
SELECT * FROM aarons;
```

این قابلیت، `CTE`ها را به یک ابزار فوق‌العاده برای شکستن کوئری‌های بسیار بزرگ و پیچیده به مراحل منطقی، خوانا و قابل مدیریت تبدیل می‌کند.

---

#### **۶. جمع‌بندی**

`CTE`ها یک ابزار عالی برای **سازماندهی و افزایش خوانایی** کوئری‌ها هستند. آن‌ها همچنین می‌توانند با مادی‌سازی هوشمندانه نتایج زیرکوئری‌های تکراری، به **بهبود عملکرد** کمک کنند. `CTE`ها به شما اجازه می‌دهند تا منطق‌های پیچیده را به واحدهای نام‌گذاری شده و قابل استفاده مجدد تقسیم کنید که این کار همکاری تیمی روی کوئری‌های بزرگ را بسیار آسان‌تر می‌کند.