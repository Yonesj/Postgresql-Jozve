`Upsert` ترکیبی از دو عملیات `INSERT` و `UPDATE` است که به شما اجازه می‌دهد این دو عمل را در قالب یک **دستور اتمی (atomic)** واحد انجام دهید. با استفاده از `Upsert`، شما می‌توانید یک ردیف را درج کنید، اما اگر آن ردیف با یک محدودیت یکتایی (`uniqueness constraint`) تداخل داشته باشد، به جای دریافت خطا، عملیات درج را به یک عملیات به‌روزرسانی تبدیل کنید.

---

### **۱. سناریو: یک جدول کلید-مقدار (`key-value`)**

برای درک بهتر، یک جدول ساده `kv` با دو ستون `key` (به عنوان کلید اصلی) و `value` ایجاد می‌کنیم. اگر تلاش کنیم یک کلید تکراری را در این جدول درج کنیم، با خطای نقض محدودیت یکتایی مواجه می‌شویم. `Upsert` به ما اجازه می‌دهد تا این خطا را به شکلی هوشمندانه مدیریت کنیم.

```postgresql
CREATE TABLE kv (
	key TEXT PRIMARY KEY,
	value TEXT
);
```

---

### **۲. پیاده‌سازی `Upsert` با `ON CONFLICT`**

برای پیاده‌سازی `Upsert`، از عبارت `ON CONFLICT` در انتهای دستور `INSERT` خود استفاده می‌کنیم.


* **حالت اول: به‌روزرسانی در صورت تداخل (`DO UPDATE`)**

    اگر می‌خواهید در صورت تداخل، ردیف موجود را به‌روزرسانی کنید، از `DO UPDATE` استفاده می‌کنید.
        
    ```postgresql
    INSERT INTO kv (key, value) 
    VALUES ('foo', '456')
    ON CONFLICT (key) DO UPDATE SET value = '...';
    ```


* **حالت دوم: نادیده گرفتن تداخل (`DO NOTHING`)**

    اگر می‌خواهید در صورت وجود تداخل، هیچ کاری انجام نشود و خطا نیز دریافت نکنید، می‌توانید از `DO NOTHING` استفاده کنید.

    ```postgresql
    INSERT INTO kv (key, value) 
    VALUES ('foo', '123')
    ON CONFLICT (key) DO NOTHING;
    ```

    این الگو برای سناریوهایی مانند "اگر وجود ندارد، درج کن؛ اگر وجود دارد، مهم نیست" بسیار رایج و مفید است. این روش از یک رفت و برگشت اضافی به پایگاه داده ( `SELECT` و سپس `INSERT`) و خطرات ناشی از `race conditions` جلوگیری می‌کند.


---

### **۳. دسترسی به مقادیر جدید با کلمه کلیدی `excluded`**

در داخل بخش `DO UPDATE`، شما به یک شیء جادویی به نام **`excluded`** دسترسی دارید. `excluded` به مقادیری اشاره دارد که شما **قصد داشتید آن‌ها را درج کنید**. این به شما اجازه می‌دهد تا ردیف موجود را با مقادیر جدید به‌روز کنید.

```postgresql
... DO UPDATE SET value = excluded.value;
```

شما همچنین به مقادیر ردیف موجود (قبل از به‌روزرسانی) نیز با استفاده از نام جدول (مثلاً `kv.value`) دسترسی دارید.

---

### **۴. `Upsert` شرطی با عبارت `WHERE`**

شما می‌توانید با افزودن یک عبارت `WHERE` به انتهای `ON CONFLICT DO UPDATE`، عملیات به‌روزرسانی را **شرطی** کنید. این به‌روزرسانی فقط در صورتی انجام می‌شود که ردیف موجود، شرط `WHERE` را برآورده کند.

**مثال: به‌روزرسانی فقط در صورت `NULL` بودن مقدار فعلی:**

```postgresql
... DO UPDATE SET value = excluded.value WHERE kv.value IS NULL;
```

این الگو یک "مسیر یک‌طرفه" ایجاد می‌کند: اگر مقداری وجود نداشته باشد، آن را درج می‌کند؛ اما اگر مقداری از قبل وجود داشته باشد، دیگر آن را تغییر نمی‌دهد. این برای سناریوهایی مانند کش کردن داده با تاریخ انقضا بسیار مفید است.

---

### **۵. کاربرد `Upsert` برای شمارنده‌ها (Counters)**

`Upsert` یک راه‌حل عالی برای پیاده‌سازی شمارنده‌ها است. شما می‌توانید در بخش `DO UPDATE`، مقدار فعلی را با مقدار جدید جمع بزنید.

```postgresql
INSERT INTO kv (key, value) 
VALUES ('homepage_hits', 10)
ON CONFLICT (key) DO UPDATE SET value = kv.value + excluded.value;
```

این الگو به شما اجازه می‌دهد تا یک شمارنده را به صورت اتمی و بدون نگرانی از شرایط رقابتی، افزایش دهید.

---

### **۶. جمع‌بندی**

`Upsert` یک قابلیت فوق‌العاده قدرتمند و کارآمد است که به شما اجازه می‌دهد منطق "درج یا به‌روزرسانی" را در یک دستور واحد و اتمی در سمت پایگاه داده پیاده‌سازی کنید. در جلسه بعد، یاد می‌گیریم که چگونه می‌توانیم نتیجه عملیات `Upsert` را در همان کوئری بازگردانیم.
