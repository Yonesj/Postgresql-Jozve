یک `Materialized View` تقریباً شبیه به یک نمای معمولی (`View`) است، با یک تفاوت کلیدی که در کلمه "مادی سازی شده" (materialized) نهفته است.

---

### **۱. تفاوت کلیدی `View` با `Materialized View`**

**نمای معمولی (View):** یک نمای معمولی چیزی جز یک **کوئری نام گذاری شده** نیست. داده‌های آن در زمان اجرا (`runtime`) و با هر بار فراخوانی محاسبه می‌شوند. به همین دلیل، داده‌های آن **همیشه به‌روز** هستند، اما هیچ بهبود عملکردی در زمان خواندن ایجاد نمی‌کنند.

**Materialized View:** یک Materialized View، نتیجه کوئری زیربنایی خود را به صورت فیزیکی **روی دیسک ذخیره می‌کند**، انگار که یک **کش (cache)** از داده‌هاست.

  *   **مزیت اصلی:** خواندن از یک Materialized View فوق‌العاده سریع است، زیرا دیگر نیازی به اجرای کوئری پرهزینه اصلی نیست و داده‌ها مستقیماً از روی دیسک خوانده می‌شوند.
  *   **عیب اصلی:** داده‌های آن به مرور زمان **کهنه (stale)** می‌شوند و به‌روز نیستند. شما باید آن را به صورت دستی (یا با یک زمان‌بندی مشخص) **تازه‌سازی (refresh)** کنید.

---

### **۲. چه زمانی از `Materialized View` استفاده کنیم؟**

نماهای مادی سازی شده برای سناریوهایی ایده‌آل هستند که:

*   کوئری زیربنایی بسیار **پرهزینه و زمان‌بر** است (مانند گزارش‌های آماری و تحلیلی پیچیده).
*   نیاز به داده‌های **کاملاً زنده و لحظه‌ای** وجود ندارد و کهنه بودن داده تا حدودی قابل قبول است (مثلاً گزارشی که یک بار در ماه به‌روز می‌شود).

---

### **۳. کاربرد عملی: ترکیب داده‌های قدیمی و زنده**

یک الگوی بسیار رایج و هوشمندانه، ترکیب یک Materialized View (برای داده‌های قدیمی) با یک نمای معمولی (برای داده‌های زنده) است.

**مراحل پیاده‌سازی:**

1.  **ایجاد `Materialized View` برای داده‌های قدیمی تر:** یک Materialized View ایجاد می‌کنیم که داده‌های آماری را برای یک بازه زمانی در گذشته (مثلاً تمام روزها به جز دو روز اخیر) محاسبه و ذخیره می‌کند. این کوئری فقط یک بار در روز (مثلاً نیمه‌شب) اجرا و تازه‌سازی می‌شود.
    ```postgresql
    CREATE MATERIALIZED VIEW bookmarks_rollup_historic AS (
      SELECT saved_on, count(*) 
      FROM bookmarks 
      WHERE saved_on < (CURRENT_DATE - INTERVAL '1 day') 
      GROUP BY saved_on
    );
    ```

3.  **ترکیب نتایج با `UNION` در یک `View` نهایی:** یک نمای معمولی نهایی ایجاد می‌کنیم که نتایج Materialized View (داده‌های تاریخی کش شده) را با داده‌های زنده `UNION` می‌کند.
    ```postgresql
    CREATE VIEW bookmarks_rollup AS (
      SELECT * 
      FROM bookmarks_rollup_historic
      UNION ALL
      SELECT saved_on, count(*) 
      FROM bookmarks 
      WHERE saved_on >= CURRENT_DATE - INTERVAL '1 day' 
      GROUP BY saved_on
    );
    ```

با این روش، کاربران همیشه با کوئری زدن از `bookmarks_rollup`، به یک دید کامل و ترکیبی از داده‌های تاریخی و زنده دسترسی دارند، در حالی که بخش عمده و پرهزینه محاسبات فقط یک بار در روز انجام می‌شود.

---

### **۴. تازه‌سازی یک `Materialized View`**

برای به‌روزرسانی داده‌های یک Materialized View، باید از دستور `REFRESH MATERIALIZED VIEW` استفاده کنید.

```postgresql
REFRESH MATERIALIZED VIEW bookmarks_rollup_historic;
```

این عملیات، کوئری اصلی را دوباره اجرا کرده و نتایج جدید را جایگزین داده‌های قدیمی می‌کند. این فرآیند می‌تواند زمان‌بر باشد.

!!! note "**تازه‌سازی همزمان (CONCURRENTLY)**"
    با استفاده از گزینه `CONCURRENTLY`، می‌توانید Materialized View را بدون قفل کردن آن برای عملیات خواندن (`SELECT`) تازه‌سازی کنید. این کار برای سیستم‌هایی که نیاز به دسترسی مداوم دارند، حیاتی است، اما پیش‌نیازهایی مانند داشتن یک ایندکس `UNIQUE` روی Materialized View دارد.

---

### **۵. جمع‌بندی**

Materialized Views ابزاری فوق‌العاده برای بهبود عملکرد خواندن در کوئری‌های پرهزینه هستند، به قیمت اینکه داده‌ها ممکن است کمی کهنه باشند. با ترکیب هوشمندانه آن‌ها با نماهای معمولی، می‌توانید به یک تعادل عالی بین عملکرد و به‌روز بودن داده‌ها دست پیدا کنید.