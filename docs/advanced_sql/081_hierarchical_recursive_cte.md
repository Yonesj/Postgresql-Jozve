در این جلسه یاد می‌گیریم چگونه داده‌های سلسله‌مراتبی (`hierarchical data`) را با استفاده از یک CTE بازگشتی پیمایش کنیم. منظور از داده‌های سلسله‌مراتبی، داده‌هایی است که در یک جدول واحد ذخیره شده‌اند و هر ردیف می‌تواند به یک ردیف دیگر در همان جدول به عنوان والد (`parent`) ارجاع دهد.

---

### **۱. سناریو: پیمایش یک جدول دسته‌بندی محصولات**

فرض کنید یک جدول `categories` داریم که در آن، هر دسته‌بندی می‌تواند یک `parent_id` داشته باشد که به `id` یک دسته‌بندی دیگر در همان جدول اشاره می‌کند. برای مثال، دسته‌بندی "دوربین‌های canon" زیرمجموعه "دوربین‌ها"، "دوربین‌ها" زیرمجموعه "تجهیزات ویدئویی" و "تجهیزات ویدئویی" زیرمجموعه "لوازم الکترونیکی" است.

```
categories(id, name, parent_id)
```

هدف ما این است که با استفاده از یک CTE بازگشتی، مسیر کامل هر دسته‌بندی را از ریشه تا خود آن، تولید و نمایش دهیم.

---

### **۲. پیاده‌سازی گام به گام CTE بازگشتی**

1.  **بخش پایه (Anchor Member):**
    کار را با بخش غیر بازگشتی شروع می‌کنیم. در این بخش، ما ردیف‌هایی را انتخاب می‌کنیم که نقطه شروع سلسله‌مراتب ما هستند. در این مثال، این ردیف‌ها، دسته‌بندی‌های ریشه هستند، یعنی آن‌هایی که `parent_id` آن‌ها `NULL` است. در این مرحله، یک ستون جدید به نام `path` ایجاد می‌کنیم که در ابتدا فقط شامل نام خود دسته‌بندی ریشه است.

2.  **بخش بازگشتی (Recursive Member):**
    در این بخش، ما نتیجه تولید شده در مرحله قبل (که در اولین تکرار، همان دسته‌بندی‌های ریشه است) را با خود جدول `categories` **`JOIN`** می‌کنیم. شرط `JOIN` به این صورت است: `all_categories.id = categories.parent_id`.
    این شرط به ما اجازه می‌دهد تا در هر مرحله، فرزندان مستقیم ردیف‌های مرحله قبل را پیدا کنیم.

3.  **تولید مسیر (Path):**
    در بخش `SELECT` قسمت بازگشتی، ما مسیر (`path`) تولید شده در مرحله قبل را گرفته و با استفاده از تابع `CONCAT`، نام دسته‌بندی فرزند (که به تازگی `JOIN` شده) را به انتهای آن اضافه می‌کنیم. این کار را با یک جداکننده (مانند `->`) انجام می‌دهیم تا مسیر خوانا باشد.

4.  **افزودن عمق (Depth):**
    برای درک بهتر ساختار، می‌توانیم یک ستون به نام `depth` نیز به کوئری خود اضافه کنیم. در بخش پایه، این ستون مقدار `1` را می‌گیرد و در هر تکرار از بخش بازگشتی، یک واحد به آن اضافه می‌شود (`depth + 1`). این کار به ما نشان می‌دهد که هر دسته‌بندی در چه سطحی از سلسله‌مراتب قرار دارد.

---

### **۳. کوئری نهایی**

کوئری نهایی که تمام این مراحل را با هم ترکیب می‌کند، به صورت زیر خواهد بود:

```postgresql
WITH RECURSIVE category_paths (id, name, path, depth) AS (
	SELECT id, name, name::text AS path, 1 AS depth
	FROM categories
	WHERE parent_id IS NULL
	UNION ALL
	SELECT c.id, c.name, concat(cp.path, ' -> ', c.name), cp.depth + 1
	FROM category_paths AS cp
	JOIN categories AS c ON cp.id = c.parent_id
)
SELECT * FROM category_paths;
```

??? note "خروجی کوئری بالا"
    <div class='centered-div'>
      <img src="../../assets/images/advanced_sql/81.png">
    </div>

---

### **۴. چرا این کار را در پایگاه داده انجام دهیم؟**

اگرچه می‌توان تمام داده‌ها را به اپلیکیشن منتقل کرده و این منطق بازگشتی را در آنجا پیاده‌سازی کرد، اما انجام این کار مستقیماً در پایگاه داده مزایای زیادی دارد:

*   **کارایی:** PostgreSQL برای اجرای کوئری‌های بازگشتی بهینه شده است و معمولاً این کار را بسیار سریع‌تر از واکشی تمام داده‌ها و پردازش آن‌ها در اپلیکیشن انجام می‌دهد.
*   **استفاده از ابزار مناسب:** CTEهای بازگشتی دقیقاً برای حل چنین مسائلی طراحی شده‌اند. بهتر است از ابزارهایی که پایگاه داده در اختیار ما قرار می‌دهد، به بهترین شکل استفاده کنیم.

شما می‌توانید خروجی `path` را به هر فرمت دیگری که می‌خواهید (مانند آرایه یا JSON) نیز تولید کنید.

---

### **۵. جمع‌بندی**

CTEهای بازگشتی یک الگوی فوق‌العاده قدرتمند برای پیمایش و تحلیل داده‌های خودارجاع و سلسله‌مراتبی هستند. با استفاده از این تکنیک، می‌توانید ساختارهای درختی پیچیده را مستقیماً در داخل پایگاه داده خود تولید و نمایش دهید و از انتقال منطق پیچیده به لایه اپلیکیشن جلوگیری کنید.