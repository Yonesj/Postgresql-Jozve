ما در بخش‌های مختلفی از دوره به مقادیر `NULL` اشاره کرده‌ایم، اما در این جلسه می‌خواهیم به صورت صریح و متمرکز به نحوه مدیریت آن‌ها بپردازیم، زیرا کار با `NULL`ها بخش جدایی‌ناپذیر کار با پایگاه داده است.

---

### **۱. اصل بنیادین: `NULL` ناشناخته است**

مهم‌ترین اصلی که باید همیشه به خاطر داشته باشید و تمام رفتارهای دیگر از آن ناشی می‌شود، این است که **`NULL` به معنای یک مقدار ناشناخته (unknown) و غیرقابل شناخت (unknowable) است**.

به همین دلیل، مقایسه `NULL` با هر مقدار دیگری، حتی با یک `NULL` دیگر، با استفاده از اپراتورهای مقایسه استاندارد (مانند `=`)، نتیجه `true` یا `false` را برنمی‌گرداند، بلکه نتیجه خود `NULL` است. پایگاه داده نمی‌تواند بگوید که آیا دو چیز ناشناخته با هم برابر هستند یا خیر.

---

### **۲. اپراتورهای مخصوص کار با `NULL`**

برای کار با `NULL`ها، باید از اپراتورهای خاصی استفاده کرد.

*   **`IS NULL` / `IS NOT NULL`:** این تنها راه صحیح برای بررسی اینکه آیا یک مقدار `NULL` است یا خیر، می‌باشد.
    ```postgresql
    SELECT NULL IS NULL; -- ture
    ```
*   **`IS DISTINCT FROM` / `IS NOT DISTINCT FROM`:** این اپراتورها شبیه به `=` و `=!` عمل می‌کنند، اما با `NULL`ها رفتار متفاوتی دارند. آن‌ها `NULL` را به عنوان یک مقدار مشخص در نظر می‌گیرند و هرگز نتیجه `NULL` برنمی‌گردانند.
    ```postgresql
    SELECT NULL IS NOT DISTINCT FROM NULL; -- true
    ```

---

### **۳. رفتار `NULL` در مرتب‌سازی (`ORDER BY`)**

به صورت پیش‌فرض در PostgreSQL، مقادیر `NULL` **بزرگتر از هر مقدار دیگری** در نظر گرفته می‌شوند. این یعنی در مرتب‌سازی صعودی (`ASC`) در انتها و در مرتب‌سازی نزولی (`DESC`) در ابتدا قرار می‌گیرند. شما می‌توانید این رفتار را با استفاده از `NULLS FIRST` و `NULLS LAST` در کوئری خود تغییر دهید.

---

### **۴. توابع کلیدی برای مدیریت `NULL`**

دو تابع بسیار مفید برای کار با `NULL`ها وجود دارد.

*   **`COALESCE(value1, value2, ...)`:** این تابع لیستی از آرگومان‌ها را دریافت کرده و **اولین مقدار غیر `NULL`** را از سمت چپ برمی‌گرداند. این تابع یک ابزار فوق‌العاده برای ارائه یک **مقدار پیش‌فرض (default value)** به جای `NULL` است.
    در مثال زیر، اگر `parent_id` برابر `NULL` باشد، مقدار `0` بازگردانده می‌شود.

    ```postgresql
    SELECT COALESCE(parent_id, 0) FROM categories;
    ```

*   **`NULLIF(value1, value2)`:** این تابع دو آرگومان دریافت می‌کند. اگر دو آرگومان **برابر باشند**، `NULL` را برمی‌گرداند. اگر برابر نباشند، **مقدار آرگومان اول** را برمی‌گرداند. این تابع در واقع برعکس `COALESCE` عمل می‌کند و برای تولید `NULL` در شرایط خاص مفید است.

---

### **۵. هشدار نهایی: تله `NOT IN` با مقادیر `NULL`**

همانطور که در جلسه زیرکوئری‌ها اشاره شد، باید به شدت مراقب استفاده از `NOT IN` با لیستی باشید که ممکن است شامل `NULL` باشد. اگر لیست مقادیر در شرط `NOT IN` شما **حتی یک مقدار `NULL`** داشته باشد، کل کوئری **هیچ ردیفی را برنمی‌گرداند**.

!!! not "توجه"
    این یک رفتار بسیار خطرناک و گیج‌کننده است. برای جلوگیری از این مشکل، یا باید مطمئن شوید که زیرکوئری شما هرگز `NULL` تولید نمی‌کند، یا بهتر است به جای آن از `NOT EXISTS` استفاده کنید.

---

### **۶. جمع‌بندی و توصیه‌ها**

*   همیشه به یاد داشته باشید که `NULL` ناشناخته است.
*   بررسی کنید که آیا ستون‌های شما واقعاً نیاز به `nullable` بودن دارند یا خیر.
*   هرگز مقادیر ساختگی (مانند رشته خالی یا `0`) را به جای `NULL` به کار نبرید. `NULL` وجود دارد تا در مواقع لزوم استفاده شود.
*   در مقایسه‌ها مراقب رفتار `NULL` باشید و از `COALESCE` برای ارائه مقادیر پیش‌فرض در مواقع لزوم استفاده کنید.