### **جلسه ۷۹: ترکیب CTE با توابع پنجره‌ای**

در این جلسه، نشان می‌دهیم که چگونه می‌توان با ترکیب یک عبارت جدولی مشترک (`CTE`) و یک تابع پنجره‌ای (`window function`)، همان مسئله "N سطر برتر به ازای هر گروه" را که قبلاً با `LATERAL JOIN` حل کرده بودیم، به روشی متفاوت و بسیار کارآمد حل کنیم.

---

#### **۱. سناریو: پیدا کردن سه بوکمارک اول یا آخر برای هر کاربر**

هدف ما این است که برای هر کاربر، سه بوکمارک اول یا سه بوکمارک آخر او را پیدا کنیم. چالش اصلی این است که تعداد کل بوکمارک‌های هر کاربر متفاوت است و نمی‌توان از یک شرط ساده برای این کار استفاده کرد.

---

#### **۲. راه‌حل گام به گام: شماره‌گذاری ردیف‌ها در هر پارتیشن**

1.  **استفاده از `()ROW_NUMBER`:** ابتدا با استفاده از تابع پنجره‌ای `ROW_NUMBER`، به هر بوکمارک در داخل پارتیشن مربوط به کاربر خودش، یک شماره ردیف اختصاص می‌دهیم.
    *   برای پیدا کردن **اولین** بوکمارک‌ها، پارتیشن را بر اساس `id` به صورت **صعودی (`ASC`)** مرتب می‌کنیم.
    *   برای پیدا کردن **آخرین** بوکمارک‌ها، پارتیشن را بر اساس `id` به صورت **نزولی (`DESC`)** مرتب می‌کنیم.

2.  **قرار دادن نتیجه در یک CTE:** نتیجه این کوئری را که اکنون شامل یک ستون شماره ردیف به نام `num` است، در داخل یک `CTE` به نام `ranked_bookmarks` قرار می‌دهیم.

3.  **فیلتر کردن CTE:** در نهایت، در کوئری اصلی، به سادگی `CTE` خود را فیلتر می‌کنیم تا فقط ردیف‌هایی را که شماره آن‌ها کمتر یا مساوی ۳ است، انتخاب کنیم.
    
```postgresql
WITH ranked_bookmarks AS (
	SELECT 
		*, ROW_NUMBER() OVER (
			PARTITION BY user_id 
			ORDER BY id ASC
		) AS num 
	FROM bookmarks;
)
SELECT * 
FROM ranked_bookmarks 
WHERE num <= 3;
```

این روش به ما اجازه می‌دهد تا به راحتی N بوکمارک اول یا آخر را برای هر کاربر استخراج کنیم.

---

#### **۳. سناریو دیگر: پیدا کردن اولین و آخرین بوکمارک هر کاربر**

می توان از تابع ROW_NUMBER و مرتب کردن پارتیشن یک بار به صورت صعودی و یک بار به صورت نزولی این مسئله را نیز حل کرد. اما یک روش هوشمندانه تر برای پیدا کردن اولین و آخرین ردیف در هر پارتیشن، استفاده از توابع پنجره‌ای `LEAD` و `LAG` است.

- `LAG(column)`: مقدار ستون مورد نظر را از ردیف **قبلی** در پارتیشن برمی‌گرداند.

- `LEAD(column)`: مقدار ستون مورد نظر را از ردیف **بعدی** در پارتیشن برمی‌گرداند.

ویژگی کلیدی این توابع این است که:

- برای **اولین ردیف** یک پارتیشن، `()LAG` مقدار `NULL` را برمی‌گرداند.
- برای **آخرین ردیف** یک پارتیشن، `()LEAD` مقدار `NULL` را برمی‌گرداند.

ما می‌توانیم از این رفتار به نفع خود استفاده کنیم. با بررسی اینکه آیا خروجی `()LAG` یا `()LEAD` برابر `NULL` است، می‌توانیم به راحتی ردیف اول و آخر هر پارتیشن را شناسایی کنیم. این روش نیز می‌تواند در داخل یک `CTE` کپسوله شده و سپس در کوئری اصلی فیلتر شود.

```postgresql
WITH user_bookmarks AS (
	SELECT
		*,
		LAG(id) OVER user_bookmarks_window IS NULL AS is_first_bookmark,
		LEAD(id) OVER user_bookmarks_window IS NULL AS is_last_bookmark,
	FROM bookmarks
	WINDOW user_bookmarks_window AS (
		PARTITION BY user_id
		ORDER BY id ASC
	)
)

SELECT *
FROM user_bookmarks
WHERE
	is_first_bookmark IS TRUE OR is_last_bookmark IS TRUE;
```

---

#### **۴. مقایسه روش‌ها و انتخاب بهترین گزینه**

ما اکنون چندین راه مختلف برای حل یک مسئله یکسان را می‌شناسیم (`LATERAL JOIN`، `CTE` با `ROW_NUMBER`، `CTE` با `LEAD`/`LAG`).

**کدام روش بهتر است؟**
هیچ پاسخ قطعی وجود ندارد. گاهی اوقات چندین مسیر برای رسیدن به یک جواب صحیح وجود دارد. اکنون که شما با این ابزارها آشنا هستید و می‌دانید چگونه طرح‌های اجرایی (`explain plans`) را بخوانید، می‌توانید:

1.  روش‌های مختلف را روی داده‌های واقعی خود تست کنید.
2.  عملکرد آن‌ها را با `EXPLAIN ANALYZE` مقایسه کنید.
3.  اگر عملکرد آن‌ها تقریباً یکسان بود، روشی را انتخاب کنید که برای شما و تیم‌تان **خواناتر و قابل فهم‌تر** است. انتخاب بر اساس ترجیح شخصی، زمانی که عملکردها برابر هستند، کاملاً قابل قبول است.

---

#### **۵. جمع‌بندی**

ترکیب `CTE` و توابع پنجره‌ای، یک الگوی بسیار قدرتمند و رایج در SQL پیشرفته است. این الگو به شما اجازه می‌دهد تا ابتدا داده‌های خود را با استفاده از توابع پنجره‌ای "غنی‌سازی" و "برچسب‌گذاری" کنید (مثلاً با افزودن شماره ردیف یا شناسایی ردیف اول و آخر) و سپس در مرحله بعد، به راحتی روی این داده‌های غنی‌شده فیلتر یا محاسبات دیگری انجام دهید.