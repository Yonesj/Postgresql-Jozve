### **جلسه ۷۵: گروه‌بندی (Grouping)**

در این جلسه، با استفاده از `GROUP BY` و توابع تجمعی (`aggregate functions`)، یاد می‌گیریم چگونه داده‌ها را خلاصه‌سازی کرده و گزارش‌های معناداری از آن‌ها استخراج کنیم. ما با دو جدول `employees` و `sales` کار خواهیم کرد.

```
employees(id, first_name, last_name, department, is_active)
sales(id, employee_id, product, region, amount, sale_date, is_returned)
```

---

#### **۱. مفهوم اصلی `GROUP BY` و اولین خطا**

دستور `GROUP BY` ردیف‌ها را بر اساس مقادیر یک یا چند ستون، در گروه‌های مجزا دسته‌بندی می‌کند. یک قانون مهم در `GROUP BY` این است که هر ستونی که در بخش `SELECT` شما قرار دارد، یا باید در عبارت `GROUP BY` نیز ذکر شود، یا باید در داخل یک **تابع تجمعی** قرار گیرد. در غیر این صورت، PostgreSQL نمی‌داند که چگونه مقادیر متعدد داخل یک گروه را در یک ردیف واحد نمایش دهد و با خطا مواجه خواهید شد.

---

#### **۲. آشنایی با توابع تجمعی رایج**

توابع تجمعی، عملیاتی را روی مجموعه‌ای از مقادیر در هر گروه انجام داده و یک نتیجه واحد برمی‌گردانند.

- `SUM(column)`: مجموع مقادیر یک ستون را محاسبه می‌کند.
- `AVG(column)`: میانگین مقادیر را محاسبه می‌کند.
- `MIN(column)` / `MAX(column)`: کمترین و بیشترین مقدار را پیدا می‌کند.
- `(*)COUNT`: تعداد کل ردیف‌ها در هر گروه را می‌شمارد.
- `ARRAY_AGG(column)`: تمام مقادیر یک ستون در یک گروه را به صورت یک آرایه (`array`) برمی‌گرداند.
- `JSON_AGG(column)` / `JSONB_AGG(column)`: مشابه `ARRAY_AGG`، اما خروجی را به صورت یک آرایه `JSON` یا `JSONB` برمی‌گرداند.

---

#### **۳. توابع تجمعی بولین: `BOOL_AND` و `BOOL_OR`**

این توابع برای کار با مقادیر بولین بسیار مفید هستند.

- `BOOL_AND(expression)`: اگر **تمام** مقادیر در یک گروه `true` باشند، نتیجه `true` و در غیر این صورت `false` خواهد بود. (معادل `AND` کردن تمام مقادیر)

- `BOOL_OR(expression)`: اگر **حداقل یکی** از مقادیر در یک گروه `true` باشد، نتیجه `true` و در غیر این صورت `false` خواهد بود. (معادل `OR` کردن تمام مقادیر)

**مثال:** پیدا کردن کارمندانی که تمام فروش‌هایشان بالای ۱۰۰ دلار بوده است:
```postgresql
SELECT employee_id, BOOL_AND(amount > 100) 
FROM sales 
GROUP BY employee_id;
```

---

#### **۴. فیلتر کردن گروه‌ها با `HAVING`**

برای فیلتر کردن نتایج **پس از** عملیات گروه‌بندی، باید از عبارت `HAVING` استفاده کنید. `HAVING` شبیه به `WHERE` است، اما روی نتایج توابع تجمعی عمل می‌کند.
**مثال:** پیدا کردن کارمندانی که هیچ فروش مرجوعی نداشته‌اند:

```postgresql
SELECT employee_id 
FROM sales 
GROUP BY employee_id 
HAVING BOOL_OR(is_returned) IS FALSE;
```

---

#### **۵. فیلتر کردن در داخل توابع تجمعی با `FILTER`**

یک قابلیت بسیار قدرتمند در PostgreSQL، امکان فیلتر کردن مقادیری است که به یک تابع تجمعی وارد می‌شوند. این کار به شما اجازه می‌دهد تا چندین محاسبه تجمعی مختلف را در یک کوئری واحد انجام دهید.

**مثال:** شمارش تعداد فروش‌های مرجوعی و غیرمرجوعی برای هر کارمند:

```postgresql
SELECT
  employee_id,
  COUNT(*) FILTER (WHERE is_returned = true) AS returned_sales,
  COUNT(*) FILTER (WHERE is_returned = false) AS non_returned_sales
FROM sales 
GROUP BY employee_id;
```

شما می‌توانید از `FILTER` با دیگر توابع تجمعی مانند `STRING_AGG` نیز استفاده کنید تا لیستی از محصولات مرجوعی را برای هر کارمند تهیه کنید.

```postgresql
SELECT
  string_agg(product, ', ') FILTER (WHERE is_returned = true) AS returned_products
FROM sales 
GROUP BY employee_id;
```

---

#### **۶. تفاوت `(*)COUNT` با `COUNT(column)`**

*   `(*)COUNT`: تعداد **کل ردیف‌ها** را در گروه می‌شمارد. این روش بهینه شده و سریع است.
*   `COUNT(column)`: تعداد ردیف‌هایی را که در ستون مشخص شده، مقدار **غیر `NULL`** دارند، می‌شمارد.

توصیه می‌شود برای شمارش ردیف‌ها، همیشه از `(*)COUNT` استفاده کنید، مگر اینکه به طور خاص نیاز به شمارش مقادیر غیر `NULL` داشته باشید.

---

#### **۷. ترکیب `GROUP BY` با `JOIN`**

شما به راحتی می‌توانید عملیات گروه‌بندی را با `JOIN` ترکیب کنید. برای مثال، می‌توانید جدول `sales` را به جدول `employees` متصل کرده و سپس نتایج را بر اساس `employee.id` گروه‌بندی کنید تا بتوانید نام کارمندان را در گزارش خود نمایش دهید.

```postgresql
SELECT
	e.id,
	(e.first_name || ' ' || e.last_name) AS employee_name
FROM sales
JOIN employees AS e ON sales.employee_id = e.id
GROUP BY e.id;
```

در این حالت، اگرچه شما بر اساس `id` گروه‌بندی کرده‌اید، اما می‌توانید از دیگر ستون‌های جدول `employees` (مانند `first_name` و `last_name`) در بخش `SELECT` استفاده کنید، زیرا آن‌ها به صورت تابعی به کلید اصلی وابسته هستند.

در جلسه بعد، به سراغ روش‌های پیچیده‌تر گروه‌بندی مانند `GROUPING SETS`، `ROLLUPS` و `CUBES` خواهیم رفت.