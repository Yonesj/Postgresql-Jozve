سینتکس row value (که به آن Row Constructor نیز می‌گویند) یک قابلیت بسیار مفید است که به شما اجازه می‌دهد تا چندین مقدار از ستون‌های مختلف را به عنوان یک مقدار واحد در نظر گرفته و با مجموعه‌ای دیگر از مقادیر مقایسه کنید. این سینتکس، کوئری‌های مقایسه‌ای پیچیده را به شدت ساده و خوانا می‌کند.

---

### **۱. معرفی سینتکس row value**

شما می‌توانید با قرار دادن چندین مقدار در داخل پرانتز، یک "row value" ایجاد کنید. کلمه کلیدی `ROW` نیز برای این کار قابل استفاده است اما اختیاری است.

```postgresql
SELECT (1, 2, 3);
-- معادل است با
SELECT ROW(1, 2, 3);
```

سپس می‌توانید این row value ها را با یکدیگر مقایسه کنید. یک نکته جالب در مورد مقایسه با `NULL` این است که اگر حتی یکی از مقادیر متناظر در دو ردیف با هم برابر نباشد، PostgreSQL نتیجه را `false` برمی‌گرداند، نه `NULL`، زیرا می‌داند که این دو ردیف تحت هیچ شرایطی نمی‌توانند با هم برابر باشند.

```postgresql
SELECT (1, 2, 3) = (1, 2, 3);    -- ture
SELECT (1, 2, 3) = (1, 2, 4);    -- false
SELECT (1, 2, 3) = (1, NULL, 3); -- null
SELECT (1, 2, 3) = (1, NULL, 4); -- false
```

---

### **۲. کاربرد اصلی: پیاده‌سازی صفحه‌بندی مبتنی بر نشانگر (Cursor-Based Pagination)**

یکی از بهترین و پرکاربردترین موارد استفاده از سینتکس row value، پیاده‌سازی یک الگوی صفحه‌بندی به نام **صفحه‌بندی مبتنی بر نشانگر (cursor-based pagination)** است که به آن keyset pagination نیز می‌گویند. این الگو جایگزین بسیار بهینه‌تری برای صفحه‌بندی سنتی مبتنی بر `OFFSET` است، به خصوص برای مجموعه داده‌های بزرگ.

**مراحل پیاده‌سازی:**

1.  **مرتب‌سازی قطعی (Deterministic Ordering):** اولین قدم، داشتن یک ترتیب مرتب‌سازی کاملاً قطعی است. شما باید کوئری خود را بر اساس مجموعه‌ای از ستون‌ها `ORDER BY` کنید و برای تضمین یکتایی و قطعیت کامل، همیشه ستون کلید اصلی (`id`) را به عنوان آخرین ستون در `ORDER BY` خود قرار دهید. در این صورت حتی اگر ستون های قبل id در order by مقادیر یکسانی داشته باشند، تضمین می شود یک ترتیب قطعی برای ردیف ها وجود خواهد داشت.

2.  **بازگرداندن نشانگر (Cursor) به کلاینت:** پس از نمایش صفحه اول نتایج، کلاینت باید مقادیر ستون‌های مرتب‌سازی شده از **آخرین ردیف مشاهده شده** را به عنوان "نشانگر" یا "مکان‌نما" ذخیره کند.

3.  **درخواست صفحه بعدی:** برای درخواست صفحه بعدی، کلاینت این نشانگر را به سرور ارسال می‌کند. سپس، در کوئری صفحه بعدی، ما با استفاده از سینتکس row value، به دنبال ردیف‌هایی می‌گردیم که row value آن‌ها (بر اساس ستون‌های مرتب‌سازی) **بزرگتر از** row value نشانگر باشد.

**مثال:**  فرض کنید کلاینت صفحه اول کاربران را درخواست کرده است:
```postgresql
SELECT * FROM users
ORDER BY first_name, last_name, id
LIMIT 10;
```

برای گرفتن صفحه بعد، کلاینت باید نشانگر را برگرداند. اگر آخرین ردیف صفحه اول ('Aaliyah', 'Bashirian', 322714) بوده باشد، کوئری صفحه بعد این گونه خواهد بود:

```postgresql
SELECT * FROM users
WHERE (first_name, last_name, id) > ('Aaliyah', 'Bashirian', 322714)
ORDER BY first_name, last_name, id
LIMIT 10;
```

این کوئری به سادگی و با کارایی بالا، صفحه بعدی نتایج را پیدا می‌کند. سینتکس row value ما را از نوشتن یک شرط `WHERE` بسیار پیچیده و تودرتو با چندین `OR` و `AND` بی‌نیاز می‌کند.

---

### **۳. کاربرد دیگر: ساده‌سازی مقایسه‌ها در اسکیمای نامناسب**

سینتکس row value می‌تواند برای ساده‌سازی مقایسه‌ها در اسکیمای داده‌ای که به صورت بهینه طراحی نشده است، بسیار مفید باشد. برای مثال، اگر تاریخ در سه ستون مجزای `year`، `month` و `day` ذخیره شده باشد، نوشتن یک شرط `BETWEEN` برای یک بازه زمانی که شامل چند ماه است، بسیار پیچیده خواهد بود.

با استفاده از سینتکس row value، می‌توانیم این سه ستون را به عنوان یک مقدار واحد در نظر گرفته و به راحتی آن را با مقادیر شروع و پایان بازه مقایسه کنیم.

```postgresql
... WHERE (year, month, day) BETWEEN (2025, 1, 20) AND (2025, 3, 3)
```

این سینتکس، پیچیدگی مقایسه‌های چند ستونی را به شدت کاهش داده و کوئری را بسیار خواناتر می‌کند.

---

### **۴. جمع‌بندی**

سینتکس row value یک ابزار قدرتمند و خوانا برای مقایسه همزمان چندین مقدار است. این قابلیت به خصوص در پیاده‌سازی صفحه‌بندی مبتنی بر نشانگر و همچنین در ساده‌سازی کوئری‌ها روی اسکیمای داده‌ای نامناسب، فوق‌العاده مفید و کارآمد است.