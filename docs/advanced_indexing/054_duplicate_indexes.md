### **جلسه ۵۴: ایندکس‌های تکراری (Duplicate Indexes)**

همانطور که قبلاً گفتیم، هر ایندکس یک ساختار داده مجزاست که نیازمند نگهداری است و با هر عملیات `INSERT`، `UPDATE` یا `DELETE` باید به‌روز شود. بنابراین، ما باید به تعداد لازم ایندکس داشته باشیم، اما نه بیشتر از آن. یکی از چیزهایی که قطعاً به آن نیاز ندارید، یک **ایندکس تکراری (duplicate index)** است.

---

#### **۱. ایندکس تکراری چیست؟**

یک ایندکس تکراری، ایندکسی است که وجود آن هیچ مزیتی به همراه ندارد، اما هزینه نگهداری را افزایش داده و می‌تواند باعث سردرگمی شما، هم‌تیمی‌هایتان و حتی برنامه‌ریز کوئری (query planner) شود. واضح‌ترین حالت، داشتن دو ایندکس کاملاً یکسان روی یک ستون است. اما ممکن است شما به صورت تصادفی یک ایندکس تکراری ایجاد کنید، حتی اگر در نگاه اول کاملاً یکسان به نظر نرسند.

---

#### **۲. سناریوی رایج ایجاد یک ایندکس تکراری**

تصور کنید در ابتدا یک ایندکس ساده روی ستون `email` ایجاد کرده‌اید:

```postgresql
CREATE INDEX email_idx ON users (email);
```

مدتی بعد، با تغییر نیازمندی‌های کسب‌وکار، شما به یک ایندکس ترکیبی جدید نیاز پیدا می‌کنید که شامل `email` و `is_pro` است و آن را ایجاد می‌کنید:

```postgresql
CREATE INDEX email_is_pro_idx ON users (email, is_pro);
```

در این لحظه، شما یک **ایندکس تکراری** ایجاد کرده‌اید!

---

#### **۳. چرا این دو ایندکس تکراری محسوب می‌شوند؟**

برای درک این موضوع، باید به قانون **"پیشوند چپ‌ترین (leftmost prefix)"** بازگردیم. هر دو ایندکس بالا، پیشوند چپ‌ترین یکسانی دارند (یعنی هر دو با ستون `email` شروع می‌شوند).

این به این معناست که ایندکس دوم (`email_is_pro_idx`) می‌تواند تمام کارهایی را که ایندکس اول (`email_idx`) انجام می‌دهد، پوشش دهد. یک کوئری که فقط روی `email` فیلتر می‌کند (`'...' = WHERE email`)، می‌تواند به راحتی از بخش اول ایندکس ترکیبی استفاده کند.

یک کوئری که روی `email` و `is_pro` فیلتر می‌کند نیز می‌تواند از کل ایندکس ترکیبی بهره ببرد.
اما برعکس این موضوع صادق نیست؛ ایندکس اول نمی‌تواند نیازمندی‌های کوئری دوم را به صورت بهینه برآورده کند.

---

#### **۴. رفتار PostgreSQL در مواجهه با ایندکس‌های تکراری**

اگر هر دو ایندکس وجود داشته باشند و شما یک کوئری فقط روی `email` اجرا کنید، PostgreSQL معمولاً ایندکس **کوچکتر و فشرده‌تر** (یعنی `email_idx`) را انتخاب می‌کند. اما اگر شما ایندکس اول را حذف کنید، PostgreSQL به راحتی و بدون هیچ مشکلی به سراغ استفاده از ایندکس دوم (`email_is_pro_idx`) برای همان کوئری می‌رود.

این رفتار ثابت می‌کند که از نظر عملکردی، ایندکس دوم می‌تواند جایگزین ایندکس اول شود.

---

#### **۵. نتیجه‌گیری و توصیه نهایی**

زمانی که در حال اضافه کردن یا تغییر ایندکس‌ها هستید، مراقب ایندکس‌های موجود باشید. اگر یک ایندکس جدید ایجاد می‌کنید که یک ایندکس قدیمی‌تر را به عنوان "پیشوند چپ‌ترین" خود شامل می‌شود، آن ایندکس قدیمی‌تر اکنون یک ایندکس تکراری و زائد است.

در مثال بالا، شما باید ایندکس `email_idx` را **حذف کنید**، زیرا ایندکس `email_is_pro_idx` می‌تواند هم کوئری‌های مبتنی بر `email` و هم کوئری‌های مبتنی بر `email` و `is_pro` را پوشش دهد. این کار به کاهش هزینه‌های نگهداری و ساده‌سازی ساختار پایگاه داده شما کمک می‌کند.

```postgresql
DROP INDEX email_idx;
```
