### **جلسه 58: ساختار EXPLAIN**

در این جلسه، با خواندن یک طرح اجرایی (`explain plan`) ساده شروع کرده و به تدریج با افزودن فیلترها و شروط، دانش خود را در مورد ساختار آن افزایش می‌دهیم.

---

#### **۱. طرح اجرایی به عنوان یک ساختار درختی**

یک طرح اجرایی، در واقع یک **ساختار درختی (tree structure)** است که از **گره‌ها (nodes)** تشکیل شده است. گره‌هایی که در پایین‌ترین سطح قرار دارند (مانند گره‌های اسکن)، مسئول تولید ردیف‌ها هستند و این ردیف‌ها را به گره‌های والد خود در سطوح بالاتر منتقل می‌کنند.

---

#### **۲. نحوه خواندن طرح اجرایی: از داخل به خارج**

نکته بسیار مهم و شاید کمی گیج‌کننده در مورد خواندن طرح اجرایی این است که شما آن را از بالا به پایین نمی‌خوانید. شما باید آن را از **داخل به خارج (inside out)** یا از پایین به بالا بخوانید.

برای مثال، در کوئری `;EXPLAIN SELECT * FROM users LIMIT 10`، طرح اجرایی دو گره دارد:

<div class='centered-div'>
  <img src="../../assets/images/understanding_query_plans/58_1.png">
</div>

شما نمی‌توانید ابتدا `Limit` را اجرا کنید و سپس `Seq Scan` را. فرآیند واقعی به این صورت است:

1.  گره داخلی‌تر (`Seq Scan`) ابتدا کل جدول را اسکن کرده و تمام ردیف‌ها را تولید می‌کند.
2.  سپس، این ردیف‌ها را به گره والد خود (`Limit`) منتقل می‌کند.
3.  گره `Limit` از میان تمام ردیف‌های دریافتی، ۱۰ ردیف اول را جدا کرده و به عنوان خروجی نهایی برمی‌گرداند.

بنابراین، گره‌ای که در بالاترین سطح و در ابتدای خروجی `EXPLAIN` می‌بینید، در واقع آخرین عملیاتی است که قبل از بازگرداندن نتایج انجام می‌شود.

---

#### **۳. درک بهتر ساختار با فرمت JSON**

اگر درک ساختار درختی در فرمت متنی برایتان دشوار است، می‌توانید از `FORMAT JSON` استفاده کنید.

```postgresql
EXPLAIN (FORMAT JSON) SELECT ...
```

خروجی JSON به وضوح نشان می‌دهد که هر گره می‌تواند یک آرایه به نام `Plans` داشته باشد که گره‌های فرزند آن را در خود جای داده است. این به شما کمک می‌کند تا رابطه والد-فرزندی و ساختار تودرتوی طرح اجرایی را بهتر درک کنید.

```json
[
  {
    "Plan": {
      "Node Type": "Limit",
      "Parallel Aware": false,
      "Async Capable": false,
      "Startup Cost": 0.0,
      "Total Cost": 0.18,
      "Plan Rows": 10,
      "Plan Width": 40,
      "Plans": [
        {
          "Node Type": "Seq Scan",
          "Parent Relationship": "Outer",
          "Parallel Aware": false,
          "Async Capable": false,
          "Relation Name": "states",
          "Alias": "states",
          "Startup Cost": 0.0,
          "Total Cost": 22.0,
          "Plan Rows": 1200,
          "Plan Width": 40
        }
      ]
    }
  }
]
```

---

#### **۴. تفاوت بین تورفتگی‌ها: گره فرزند در مقابل ویژگی گره**

در خروجی متنی `EXPLAIN`، دو نوع تورفتگی (indentation) وجود دارد که معنای متفاوتی دارند.

- **تورفتگی با فلش (`<-`):** این نوع تورفتگی نشان‌دهنده یک **گره فرزند (child node)** است. گره‌ای که با فلش مشخص شده، یک عملیات مجزا و گسسته است که خروجی خود را به گره والدش ارسال می‌کند.

- **تورفتگی بدون فلش:** این نوع تورفتگی، یک گره جدید را نشان **نمی‌دهد**. بلکه یک **ویژگی (attribute)** یا اطلاعات اضافی در مورد گره والد بالای خود است. برای مثال، در خروجی `EXPLAIN` برای یک `Seq Scan` با شرط `WHERE`، خط `... :Filter` که با تورفتگی اما بدون فلش نمایش داده می‌شود، یک گره جدید نیست، بلکه صرفاً به ما می‌گوید که روی گره `Seq Scan` یک عملیات فیلتر نیز در حال انجام است.

<br/>

<div class='centered-div'>
  <img src="../../assets/images/understanding_query_plans/58_2.png">
</div>

---

#### **۵. جمع‌بندی**

به یاد داشته باشید که یک طرح اجرایی، یک ساختار سلسله‌مراتبی است که باید از داخلی‌ترین گره‌ها به سمت بیرون خوانده شود. گره‌های فرزند، ردیف‌ها را تولید کرده و به گره‌های والد خود منتقل می‌کنند تا در نهایت به بالاترین گره رسیده و نتیجه نهایی بازگردانده شود. اگر در مورد ساختار شک کردید، استفاده از `FORMAT JSON` می‌تواند به شفاف‌سازی رابطه بین گره‌ها کمک کند.
