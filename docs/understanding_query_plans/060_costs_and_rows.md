### **جلسه ۶۰: هزینه‌ها و ردیف‌ها (Costs and Rows)**

برای هر گره (node) در یک طرح اجرایی، مجموعه‌ای از اطلاعات عددی در داخل پرانتز نمایش داده می‌شود که در نگاه اول ممکن است رمزآلود به نظر برسند. در این جلسه، به بررسی این اطلاعات می‌پردازیم.

---

#### **۱. ساختار اطلاعات عددی**

اطلاعات هر گره شامل موارد زیر است:

```
cost=startup_cost..total_cost rows=planned_rows width=planned_width
```

- `cost`: شامل دو بخش هزینه شروع و هزینه کل است.
- `rows`: تعداد ردیف‌های تخمینی که توسط این گره تولید خواهد شد.
- `width`: عرض تخمینی هر ردیف (به بایت) که توسط این گره تولید خواهد شد.

---

#### **۲. درک هزینه‌ها (Costs)**

- **هزینه شروع (Startup Cost):** این عدد (اولین مقدار در `cost`) نشان می‌دهد که چقدر "هزینه" لازم است تا این گره **شروع به کار کند** و بتواند اولین ردیف خود را تولید کند. برای گره‌های داخلی (فرزند)، این هزینه معمولاً صفر است. برای گره‌های والد، هزینه شروع معمولاً برابر با هزینه کل گره فرزندشان است، زیرا باید منتظر بمانند تا کار گره فرزند تمام شود.

- **هزینه کل (Total Cost):** این عدد (دومین مقدار در `cost`) هزینه تخمینی کل برای اجرای کامل این گره و تمام گره‌های فرزند آن است. **هزینه کل در بالاترین گره، همان هزینه تخمینی کل کوئری است** و هدف ما در بهینه‌سازی، کاهش همین عدد است.

**واحد هزینه چیست؟**
این واحدها **قراردادی و نسبی** هستند و واحد مشخصی مانند میلی‌ثانیه ندارند. این اعداد از ترکیب عوامل مختلفی مانند هزینه خواندن یک صفحه ترتیبی، هزینه خواندن یک صفحه تصادفی و هزینه‌های پردازشی (`CPU`) محاسبه می‌شوند. ما نباید روی مقدار مطلق این اعداد تمرکز کنیم، بلکه باید از آن‌ها به عنوان یک معیار **جهت‌نما (directional)** برای مقایسه طرح‌های اجرایی مختلف و سنجش میزان بهبود کوئری‌هایمان استفاده کنیم.

---

#### **۳. درک پارامتر `rows`**

این عدد نشان‌دهنده تعداد ردیف‌هایی است که PostgreSQL **تخمین می‌زند** این گره پس از اتمام کار خود، به گره والدش **خروجی خواهد داد**.

این عدد به معنای تعداد ردیف‌هایی که باید "بررسی شوند" نیست. یک گره ممکن است میلیون‌ها ردیف را بررسی کند تا در نهایت فقط چند ردیف را به عنوان خروجی تولید کند.

**کاربرد در بهینه‌سازی:** اگر در گره‌های داخلی، تعداد بسیار زیادی ردیف در حال تولید و انتقال به سطوح بالاتر است، اما در نهایت انتظار تعداد کمی ردیف را دارید، این می‌تواند نشانه‌ای باشد که شاید راه بهتری برای فیلتر کردن و محدود کردن ردیف‌ها در مراحل اولیه وجود دارد.

---

#### **۴. درک پارامتر `width`**

این عدد، عرض یا اندازه تخمینی هر ردیف به **بایت** را نشان می‌دهد. این پارامتر به شما کمک می‌کند تا حجم داده‌ای را که در حال پردازش و انتقال است، درک کنید. برای مثال، اگر به جای `* SELECT` فقط ستون `id` (که یک bigint هشت بایتی است) را انتخاب کنید، خواهید دید که مقدار `width` به شدت کاهش می‌یابد.

**کاربرد در بهینه‌سازی:** اگر مقدار `width` بسیار بزرگ است (مثلاً به دلیل وجود ستون‌های `JSON` یا `text` حجیم که به آن‌ها نیازی ندارید)، این می‌تواند یک نشانه خوب باشد که باید لیست ستون‌های `SELECT` شده خود را محدود کنید.

---

#### **۵. یک استثنای مهم: تأثیر `LIMIT` بر هزینه‌ها**

یک نکته مهم که باید به آن توجه داشت، تأثیر `LIMIT` بر محاسبه هزینه‌هاست. اگر یک کوئری دارای `LIMIT` باشد و نیازی به مرتب‌سازی نداشته باشد، PostgreSQL می‌تواند پس از پیدا کردن تعداد ردیف‌های مورد نیاز، اجرای کوئری را **زودتر متوقف کند (end early)**.

در این حالت، ممکن است ببینید که هزینه کل گره والد (`Limit`) بسیار کمتر از هزینه کل گره فرزند (`Seq Scan`) است. این به این دلیل است که گره `Seq Scan` هرگز به طور کامل اجرا نمی‌شود و فقط تا زمانی که ۱۰ ردیف اول را پیدا کند، پیش می‌رود.

اما اگر کوئری شما شامل `ORDER BY` باشد، این بهینه‌سازی دیگر ممکن نیست، زیرا PostgreSQL برای پیدا کردن ۱۰ ردیف "صحیح"، مجبور است کل جدول را اسکن و مرتب کند.
